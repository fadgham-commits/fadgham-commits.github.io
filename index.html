<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Dash</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --grid: #11203a;
      --neon1: #00eaff;
      --neon2: #ff3af2;
      --neon3: #7bff00;
      --player: #00f5ff;
      --danger: #ff2d55;
      --platform: #1e3a5f;
      --hud: #cfe7ff;
    }
    html,body { height: 100%; margin: 0; background: var(--bg); color: var(--hud); font-family: system-ui, sans-serif; }
    #wrap { max-width: 900px; margin: 0 auto; padding: 10px; }
    #canvas { width: 100%; height: auto; border: 1px solid #17304f; background: radial-gradient(1200px 400px at 50% 10%, #09101c, #070a12); }
    #hud {
      display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; margin-top: 6px;
    }
    .bar { height: 8px; background: #112; border: 1px solid #234; position: relative; border-radius: 6px; overflow: hidden; }
    .bar > .fill { position: absolute; left:0; top:0; bottom:0; width:0; background: linear-gradient(90deg, var(--neon1), var(--neon2)); box-shadow: 0 0 8px var(--neon1); }
    button {
      background: #0f2138; color: var(--hud); border: 1px solid #204060; border-radius: 6px; padding: 6px 10px; cursor: pointer;
    }
    button:hover { border-color: var(--neon1); box-shadow: 0 0 8px #0af3; }
    small { opacity: 0.8; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="canvas" width="900" height="500"></canvas>
    <div id="hud">
      <div class="bar"><div class="fill" id="progress"></div></div>
      <div id="stats"><small>Kecepatan: <span id="spd">0</span> â€¢ Percobaan: <span id="tries">1</span></small></div>
      <div>
        <button id="restart">Restart</button>
        <button id="next">Next Level</button>
      </div>
    </div>
  </div>

  <script>
  // ===== Utilities =====
  const lerp = (a,b,t)=>a+(b-a)*t;
  const clamp = (v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const now = ()=>performance.now();

  // ===== Canvas & Context =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // ===== Input =====
  const Input = { jumpPressed:false, jumpDown:false, jumpBufferMs:120, lastPress: -9999 };
  function pressJump(){
    Input.jumpPressed = true;
    Input.jumpDown = true;
    Input.lastPress = now();
  }
  function releaseJump(){ Input.jumpDown = false; }
  window.addEventListener('keydown', e=>{ if(e.code==='Space' || e.code==='ArrowUp') { pressJump(); e.preventDefault(); }});
  window.addEventListener('keyup', e=>{ if(e.code==='Space' || e.code==='ArrowUp') { releaseJump(); e.preventDefault(); }});
  window.addEventListener('mousedown', pressJump);
  window.addEventListener('mouseup', releaseJump);
  window.addEventListener('touchstart', e=>{ pressJump(); e.preventDefault(); }, {passive:false});
  window.addEventListener('touchend', e=>{ releaseJump(); e.preventDefault(); }, {passive:false});

  // ===== Level Data (tiles in world coords) =====
  // Types: rect platform, spike (triangle), orb (jump booster)
  const LEVELS = [
    {
      name: "Neon Intro",
      speed: 360, // px/s camera scroll
      songBpm: 120, // for reference only
      length: 3400, // world length in px
      groundY: 380,
      platforms: [
        {x:0,y:380,w:3400,h:40},               // ground
        {x:650,y:320,w:140,h:20},
        {x:980,y:280,w:120,h:20},
        {x:1500,y:340,w:180,h:20},
        {x:1900,y:300,w:160,h:20},
        {x:2350,y:260,w:120,h:20},
      ],
      spikes: [
        {x:450,y:380,w:30,h:30},
        {x:820,y:380,w:30,h:30},
        {x:1130,y:280,w:30,h:30},
        {x:1600,y:340,w:30,h:30},
        {x:2050,y:300,w:30,h:30},
        {x:2700,y:380,w:30,h:30},
      ],
      orbs: [
        {x:1030,y:310,r:12,boost:480}, // air jump assist
        {x:1960,y:330,r:12,boost:520},
      ]
    },
    {
      name: "Hyper Grid",
      speed: 420,
      songBpm: 140,
      length: 3800,
      groundY: 380,
      platforms: [
        {x:0,y:380,w:3800,h:40},
        {x:900,y:320,w:120,h:20},
        {x:1120,y:280,w:100,h:20},
        {x:1400,y:320,w:140,h:20},
        {x:2200,y:320,w:160,h:20},
        {x:2600,y:280,w:120,h:20},
        {x:3000,y:240,w:100,h:20},
      ],
      spikes: [
        {x:520,y:380,w:30,h:30},
        {x:980,y:320,w:30,h:30},
        {x:1460,y:320,w:30,h:30},
        {x:1680,y:380,w:30,h:30},
        {x:2260,y:320,w:30,h:30},
        {x:3060,y:240,w:30,h:30},
        {x:3360,y:380,w:30,h:30},
      ],
      orbs: [
        {x:1160,y:310,r:12,boost:520},
        {x:2660,y:310,r:12,boost:520},
      ]
    }
  ];

  // ===== Game State =====
  const state = {
    lvlIndex: 0,
    cameraX: 0,
    attempt: 1,
    playing: true,
    deathFlash: 0,
  };

  const player = {
    w: 26, h: 26,
    x: 80, y: 0,
    vx: 0, vy: 0,
    gravity: 1400,
    jumpVel: 650,
    coyoteMs: 100,
    lastGroundTime: -9999,
    trail: [],
  };

  function loadLevel(i){
    const L = LEVELS[i];
    state.lvlIndex = i;
    state.cameraX = 0;
    state.playing = true;
    state.deathFlash = 0;
    state.attempt = (i===state.lvlIndex) ? state.attempt : 1;
    player.x = 80;
    player.y = L.groundY - player.h;
    player.vx = 0;
    player.vy = 0;
    player.trail.length = 0;
    document.getElementById('spd').textContent = L.speed.toFixed(0);
    document.getElementById('tries').textContent = state.attempt;
  }
  loadLevel(0);

  // ===== Collision helpers =====
  function rectRect(ax,ay,aw,ah,bx,by,bw,bh){
    return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
  }
  function pointInTri(px,py, tri){
    // tri points: (x,y-h),(x+w,y),(x-w,y)
    const x=tri.x,y=tri.y,w=tri.w,h=tri.h;
    const A = area(x,y-h, x+w,y, x-w,y);
    const A1 = area(px,py, x+w,y, x-w,y);
    const A2 = area(x,y-h, px,py, x-w,y);
    const A3 = area(x,y-h, x+w,y, px,py);
    return Math.abs(A-(A1+A2+A3))<0.5;
    function area(x1,y1,x2,y2,x3,y3){ return Math.abs((x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))/2); }
  }

  // ===== HUD Buttons =====
  document.getElementById('restart').onclick = ()=>{
    state.attempt++;
    loadLevel(state.lvlIndex);
  };
  document.getElementById('next').onclick = ()=>{
    const next = (state.lvlIndex+1) % LEVELS.length;
    loadLevel(next);
    state.attempt = 1;
    document.getElementById('tries').textContent = state.attempt;
  };

  // ===== Game Loop =====
  let last = now();
  function loop(){
    const t = now();
    const dt = Math.min(1/30, (t-last)/1000); // clamp dt
    update(dt);
    draw();
    last = t;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt){
    const L = LEVELS[state.lvlIndex];
    if(!state.playing) return;

    // Camera scroll
    state.cameraX += L.speed * dt;

    // Physics
    player.vy += player.gravity * dt;
    player.y += player.vy * dt;

    // Trail
    player.trail.push({x:player.x, y:player.y, t: t=>t});
    if(player.trail.length>16) player.trail.shift();

    // Ground/platform collision
    const plats = L.platforms;
    let onGround = false;
    for(const p of plats){
      // Transform world -> screen reference for collision uses world space
      if(rectRect(playerWorldX(), player.y, player.w, player.h, p.x, p.y, p.w, p.h)){
        // Snap to top of platform
        if(player.vy >= 0 && player.y+player.h > p.y && player.y < p.y){
          player.y = p.y - player.h;
          player.vy = 0;
          onGround = true;
        }
      }
    }
    const worldGround = {x:0,y:L.groundY,w:L.length,h:40}; // used by collision
    if(rectRect(playerWorldX(), player.y, player.w, player.h, worldGround.x, worldGround.y, worldGround.w, worldGround.h)){
      if(player.vy >= 0 && player.y+player.h > worldGround.y && player.y < worldGround.y){
        player.y = worldGround.y - player.h;
        player.vy = 0;
        onGround = true;
      }
    }
    if(onGround) player.lastGroundTime = now();

    // Jump logic: coyote time + jump buffer + hold-to-autojump
    const canCoyote = (now() - player.lastGroundTime) <= player.coyoteMs;
    const buffered = (now() - Input.lastPress) <= Input.jumpBufferMs;
    const wantsJump = Input.jumpPressed || (Input.jumpDown && onGround);
    if((wantsJump || buffered) && (onGround || canCoyote)){
      player.vy = -player.jumpVel;
      Input.jumpPressed = false; // consume
    }

    // Orbs (air jump boosters)
    for(const o of L.orbs){
      const dx = (playerWorldX()+player.w/2) - o.x;
      const dy = (player.y+player.h/2) - o.y;
      const hit = Math.hypot(dx,dy) <= o.r + Math.min(player.w,player.h)*0.5;
      if(hit && Input.jumpDown){
        player.vy = -o.boost;
        // add slight cooldown by moving orb out of the way
        o.x -= 99999;
      }
    }

    // Spikes death
    for(const s of L.spikes){
      // approximate with rect or triangle precise check
      const px = playerWorldX();
      const rectHit = rectRect(px,player.y,player.w,player.h, s.x-s.w, s.y-s.h, s.w*2, s.h);
      if(rectHit){
        // more precise: check player corners
        const corners = [
          {x:px, y:player.y},
          {x:px+player.w, y:player.y},
          {x:px, y:player.y+player.h},
          {x:px+player.w, y:player.y+player.h},
        ];
        if(corners.some(c=>pointInTri(c.x,c.y,s))){
          die();
          break;
        }
      }
    }

    // Win condition (reach end)
    const progress = clamp(state.cameraX / (L.length - 200), 0, 1);
    document.getElementById('progress').style.width = (progress*100).toFixed(1) + '%';
    if(state.cameraX >= L.length){
      state.playing = false;
      // soft flash to celebrate
      state.deathFlash = 0;
    }
  }

  function playerWorldX(){
    // Player stays near left of view; world X is cameraX + screenX
    return state.cameraX - 80 + player.x;
  }

  function die(){
    state.playing = false;
    state.deathFlash = 1;
    setTimeout(()=>{
      const i = state.lvlIndex;
      state.attempt++;
      loadLevel(i);
    }, 500);
  }

  // ===== Rendering =====
  function draw(){
    const L = LEVELS[state.lvlIndex];

    // Clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Background parallax neon grid
    drawGrid(0.35, 22, '#0b1f38', '#09203a');
    drawGrid(0.75, 40, '#0e2748', '#0a2748');

    // Death/win flash overlay
    if(state.deathFlash>0){
      ctx.fillStyle = `rgba(255,45,85,${state.deathFlash})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      state.deathFlash = Math.max(0, state.deathFlash - 0.08);
    }

    // World to screen offset
    const ox = -state.cameraX + 80;

    // Platforms
    for(const p of L.platforms){
      const x = p.x + ox, y = p.y;
      if(x+p.w<0 || x>canvas.width) continue;
      glowRect(x,y,p.w,p.h, 8, '#1e3a5f', '#2d5b9f');
    }

    // Spikes
    for(const s of L.spikes){
      const x = s.x + ox, y = s.y;
      if(x+s.w<0 || x>canvas.width) continue;
      glowSpike(x,y,s.w,s.h, 10, '#ff2d55', '#ff6a8b');
    }

    // Orbs
    for(const o of L.orbs){
      const x = o.x + ox, y = o.y;
      if(x+o.r<0 || x>canvas.width) continue;
      glowCircle(x,y,o.r, 10, '#00eaff', '#7bff00');
    }

    // Player trail
    ctx.save();
    for(let i=player.trail.length-1;i>=0;i--){
      const p = player.trail[i];
      const alpha = i/player.trail.length*0.5;
      ctx.fillStyle = `rgba(0,245,255,${alpha})`;
      ctx.fillRect((playerWorldX()-state.cameraX+80), player.y, player.w, player.h);
    }
    ctx.restore();

    // Player
    const sx = playerWorldX() + ox;
    glowRect(sx, player.y, player.w, player.h, 14, '#00f5ff', '#00eaff');

    // Floor line
    ctx.globalAlpha = 0.4;
    ctx.strokeStyle = '#0af';
    ctx.beginPath();
    ctx.moveTo(0, L.groundY);
    ctx.lineTo(canvas.width, L.groundY);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Level name
    ctx.fillStyle = '#bde3ff';
    ctx.font = '14px monospace';
    ctx.fillText(L.name, 8, 18);
  }

  function drawGrid(scale, gap, color1, color2){
    ctx.save();
    ctx.globalAlpha = scale;
    ctx.strokeStyle = color1;
    const shift = (state.cameraX*0.15) % gap;
    for(let x= -shift; x<canvas.width; x+=gap){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
    }
    ctx.strokeStyle = color2;
    const vshift = (state.cameraX*0.07) % gap;
    for(let y= -vshift; y<canvas.height; y+=gap){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
    }
    ctx.restore();
  }

  function glowRect(x,y,w,h, blur, base, glow){
    ctx.save();
    ctx.fillStyle = base;
    ctx.shadowColor = glow;
    ctx.shadowBlur = blur;
    ctx.fillRect(x,y,w,h);
    ctx.restore();
    ctx.strokeStyle = glow;
    ctx.globalAlpha = 0.35;
    ctx.strokeRect(x,y,w,h);
    ctx.globalAlpha = 1;
  }

  function glowCircle(x,y,r, blur, base, glow){
    ctx.save();
    ctx.fillStyle = base;
    ctx.shadowColor = glow;
    ctx.shadowBlur = blur;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.strokeStyle = glow;
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function glowSpike(x,y,w,h, blur, base, glow){
    ctx.save();
    ctx.fillStyle = base;
    ctx.shadowColor = glow;
    ctx.shadowBlur = blur;
    ctx.beginPath();
    ctx.moveTo(x, y-h);
    ctx.lineTo(x+w, y);
    ctx.lineTo(x-w, y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    ctx.strokeStyle = glow;
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.moveTo(x, y-h);
    ctx.lineTo(x+w, y);
    ctx.lineTo(x-w, y);
    ctx.closePath();
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
  </script>
</body>
</html>
