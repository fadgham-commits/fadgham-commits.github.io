<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Neon Grid: Parallax</title>
  <style>
    :root{
      --bg:#0a0f1f;
      --panel:#0c1838;
      --border:#183568;
      --grid-cyan:rgba(0,229,255,0.08);
      --grid-magenta:rgba(255,46,249,0.08);
      --neon-cyan:#00e5ff;
      --neon-magenta:#ff2ef9;
      --neon-yellow:#ffe600;
      --neon-green:#00ffa6;
      --neon-red:#ff3b3b;
      --text:#e6f7ff;
      --muted:#9fc7ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px at 50% 50%, #0e1730 0%, var(--bg) 60%, #060a19 100%); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color:var(--text)}
    header{
      display:flex;align-items:center;justify-content:space-between;
      padding:10px 16px;border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(20,34,64,0.35), transparent);
      position:sticky;top:0;z-index:10;
      backdrop-filter:saturate(140%) blur(6px);
    }
    h1{font-size:18px;letter-spacing:0.06em;margin:0;color:var(--neon-cyan);text-shadow:0 0 8px rgba(0,229,255,0.6)}
    .controls{display:flex;gap:10px;flex-wrap:wrap}
    .btn{
      border:1px solid #29487a;background:linear-gradient(180deg,#132347,#0c1936);
      color:var(--text);padding:8px 10px;border-radius:8px;cursor:pointer;
      box-shadow:0 0 10px rgba(0,229,255,0.1) inset, 0 0 12px rgba(255,46,249,0.08);
      transition:transform .05s ease, box-shadow .2s ease, border-color .2s ease;
      font-weight:600;font-size:13px;letter-spacing:.03em;
    }
    .btn:hover{border-color:var(--neon-cyan); box-shadow:0 0 14px rgba(0,229,255,0.2) inset, 0 0 14px rgba(255,46,249,0.18)}
    .btn:active{transform:scale(0.98)}
    .hud{
      display:grid;grid-template-columns:1fr auto;gap:12px;padding:8px 16px;border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(20,34,64,0.25), transparent);
      backdrop-filter:saturate(140%) blur(6px);
    }
    .bars{display:flex;gap:12px;flex-wrap:wrap}
    .bar{min-width:220px;flex:1;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px;position:relative}
    .bar-label{font-size:12px;color:var(--muted);margin-bottom:4px;text-shadow:0 0 6px rgba(184,215,255,0.25)}
    .bar-fill{
      height:10px;border-radius:8px;background:linear-gradient(90deg,var(--neon-green),var(--neon-cyan));
      box-shadow:0 0 8px rgba(0,229,255,0.6), 0 0 12px rgba(0,255,166,0.3) inset;
      width:100%;
      transition:width .2s ease;
    }
    .bar-fill.energy{background:linear-gradient(90deg,#ffd166,var(--neon-yellow)); box-shadow:0 0 8px rgba(255,230,0,0.6), 0 0 12px rgba(255,209,102,0.3) inset}
    .stats{display:flex;gap:16px;align-items:center;flex-wrap:wrap}
    .stat{
      display:flex;align-items:center;gap:8px;border:1px solid var(--border);background:var(--panel);padding:6px 10px;border-radius:10px;
      box-shadow:0 0 10px rgba(0,229,255,0.08) inset;
      font-size:13px;
    }
    .chip{width:14px;height:14px;border-radius:50%;box-shadow:0 0 10px currentColor}
    .chip.hp{color:var(--neon-green)}
    .chip.energy{color:var(--neon-yellow)}
    .chip.coin{color:#ffd166}
    .chip.stage{color:var(--neon-magenta)}
    .shop{
      display:flex;gap:10px;flex-wrap:wrap; padding:8px 16px; border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(20,34,64,0.20), transparent);
    }
    .skin-card{
      border:1px solid var(--border);background:#0b1430;border-radius:12px;padding:8px 10px; min-width:160px;
      display:flex;align-items:center;justify-content:space-between; gap:8px;
    }
    .skin-swatch{
      width:38px;height:38px;border-radius:8px;box-shadow:0 0 12px currentColor, inset 0 0 10px rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.1);
    }
    .skin-name{font-weight:700; font-size:13px}
    .skin-price{font-size:12px;color:#ffd166}
    .canvas-wrap{
      position:relative; margin:14px auto; max-width:900px; padding:10px; border:1px solid var(--border); border-radius:14px;
      background:linear-gradient(180deg, rgba(20,34,64,0.20), rgba(10,22,49,0.35));
      box-shadow:0 0 18px rgba(0,229,255,0.06), inset 0 0 14px rgba(255,46,249,0.05);
    }
    canvas{width:100%; height:540px; display:block; background:#0b1633; border-radius:12px}
    .overlay-msg{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
      font-size:22px; letter-spacing:.04em; color:#a7eaff; text-shadow:0 0 12px rgba(0,229,255,0.4);
    }
    footer{padding:18px 16px;color:#8fb7ff;font-size:12px;opacity:.9}
    /* Neon grid behind the canvas */
    .canvas-wrap::before{
      content:""; position:absolute; inset:10px; border-radius:12px; pointer-events:none;
      background:
        linear-gradient(90deg, var(--grid-cyan) 1px, transparent 1px) 0 0 / 48px 100%,
        linear-gradient(0deg, var(--grid-magenta) 1px, transparent 1px) 0 0 / 100% 48px;
      mix-blend-mode:screen; filter:drop-shadow(0 0 6px rgba(0,229,255,0.15));
    }
  </style>
</head>
<body>
  <header>
    <h1>NEON GRID: PARALLAX</h1>
    <div class="controls">
      <button class="btn" id="btnStart">Mulai</button>
      <button class="btn" id="btnPause">Pause</button>
      <button class="btn" id="btnReset">Reset</button>
      <button class="btn" id="btnNextStage">Lewati Stage</button>
    </div>
  </header>

  <div class="hud">
    <div class="bars">
      <div class="bar">
        <div class="bar-label">HP</div>
        <div class="bar-fill" id="hpBar"></div>
      </div>
      <div class="bar">
        <div class="bar-label">Energi</div>
        <div class="bar-fill energy" id="energyBar"></div>
      </div>
    </div>
    <div class="stats">
      <div class="stat"><span class="chip hp"></span> <span id="hpText">100 / 100</span></div>
      <div class="stat"><span class="chip energy"></span> <span id="energyText">0</span></div>
      <div class="stat"><span class="chip coin"></span> <span id="coinText">0</span></div>
      <div class="stat"><span class="chip stage"></span> <span id="stageText">Stage 1</span></div>
    </div>
  </div>

  <div class="shop" id="shop">
    <div class="skin-card">
      <div class="skin-swatch" style="color:#00e5ff; background:radial-gradient(20px at 50% 50%, rgba(0,229,255,0.4), transparent)"></div>
      <div>
        <div class="skin-name">Cyan Core</div>
        <div class="skin-price">Harga: 25 coin</div>
      </div>
      <button class="btn buy" data-skin="cyan" data-price="25">Beli</button>
    </div>
    <div class="skin-card">
      <div class="skin-swatch" style="color:#ff2ef9; background:radial-gradient(20px at 50% 50%, rgba(255,46,249,0.35), transparent)"></div>
      <div>
        <div class="skin-name">Magenta Pulse</div>
        <div class="skin-price">Harga: 40 coin</div>
      </div>
      <button class="btn buy" data-skin="magenta" data-price="40">Beli</button>
    </div>
    <div class="skin-card">
      <div class="skin-swatch" style="color:#ffe600; background:radial-gradient(20px at 50% 50%, rgba(255,230,0,0.4), transparent)"></div>
      <div>
        <div class="skin-name">Solar Neon</div>
        <div class="skin-price">Harga: 60 coin</div>
      </div>
      <button class="btn buy" data-skin="yellow" data-price="60">Beli</button>
    </div>
    <div class="skin-card">
      <div class="skin-swatch" style="color:#00ffa6; background:radial-gradient(20px at 50% 50%, rgba(0,255,166,0.35), transparent)"></div>
      <div>
        <div class="skin-name">Emerald Flux</div>
        <div class="skin-price">Harga: 80 coin</div>
      </div>
      <button class="btn buy" data-skin="green" data-price="80">Beli</button>
    </div>
  </div>

  <div class="canvas-wrap">
    <canvas id="game" width="900" height="540"></canvas>
    <div class="overlay-msg" id="overlay">Tekan "Mulai" untuk bermain</div>
  </div>

  <footer>
    Kontrol: WASD/Arrow untuk bergerak • Spasi untuk menembak (butuh energi) • P untuk pause • Enter untuk lanjut stage setelah boss
  </footer>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const hpBar = document.getElementById('hpBar');
    const energyBar = document.getElementById('energyBar');
    const hpText = document.getElementById('hpText');
    const energyText = document.getElementById('energyText');
    const coinText = document.getElementById('coinText');
    const stageText = document.getElementById('stageText');
    const overlay = document.getElementById('overlay');
    const shop = document.getElementById('shop');

    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');
    const btnNextStage = document.getElementById('btnNextStage');

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // Player
    const basePlayer = {
      x: WIDTH/2, y: HEIGHT-80, w: 26, h: 26,
      speed: 3.4,
      maxHP: 100, hp: 100,
      maxEnergy: 100, energy: 20,  // awalnya rendah, harus kumpulkan
      skin: 'cyan',
      shootCost: 12,
      damage: 12
    };

    // Game state
    let state = {
      running: false,
      paused: false,
      stage: 1,
      coins: 0,
      bullets: [],
      enemies: [],
      pickups: [], // energi & HP
      particles: [],
      keys: {},
      boss: null,
      spawnTimer: 0,
      difficulty: 1,
      maxEnemiesOnScreen: 8, // penyeimbang spawn
      player: {...basePlayer},
      stageClear: false
    };

    // Utility colors
    function colorForSkin(skin){
      switch(skin){
        case 'magenta': return '#ff2ef9';
        case 'yellow': return '#ffe600';
        case 'green': return '#00ffa6';
        default: return '#00e5ff';
      }
    }

    // Particles
    function addParticle(x,y,color){
      state.particles.push({x,y,life:20,color,dx:(Math.random()-0.5)*2,dy:(Math.random()-0.5)*2});
    }

    // Reset
    function reset(){
      state = {
        running: false, paused: false,
        stage: 1, coins: 0, bullets: [], enemies: [], pickups: [], particles: [],
        keys: {}, boss: null, spawnTimer:0, difficulty:1, maxEnemiesOnScreen:8,
        player: {...basePlayer, hp: basePlayer.maxHP, energy: 20, x: WIDTH/2, y: HEIGHT-80},
        stageClear: false
      };
      updateHUD();
      overlay.textContent = 'Tekan "Mulai" untuk bermain';
      overlay.style.display = 'flex';
    }

    function start(){
      if (state.running) return;
      state.running = true;
      state.paused = false;
      overlay.style.display = 'none';
    }

    function pause(){
      if (!state.running) return;
      state.paused = !state.paused;
      overlay.style.display = state.paused ? 'flex' : 'none';
      overlay.textContent = state.paused ? 'PAUSE' : '';
    }

    function nextStage(){
      if (!state.stageClear) return;
      state.stage++;
      state.difficulty += 0.9;
      state.maxEnemiesOnScreen = Math.min(12, 6 + Math.floor(state.difficulty));
      state.enemies.length = 0;
      state.pickups.length = 0;
      state.boss = null;
      state.stageClear = false;
      state.player.energy = Math.min(state.player.maxEnergy, state.player.energy + 15);
      stageText.textContent = 'Stage ' + state.stage;
      overlay.style.display = 'none';
    }

    // Shop
    shop.addEventListener('click', (e)=>{
      const btn = e.target.closest('.buy');
      if (!btn) return;
      const skin = btn.dataset.skin;
      const price = parseInt(btn.dataset.price,10);
      if (state.coins >= price){
        state.coins -= price;
        state.player.skin = skin;
        addParticle(state.player.x, state.player.y, colorForSkin(skin));
        updateHUD();
      }
    });

    // Controls
    window.addEventListener('keydown', (e)=>{
      state.keys[e.key.toLowerCase()] = true;
      if (e.key === ' '){ e.preventDefault(); shoot(); }
      if (e.key.toLowerCase() === 'p'){ pause(); }
      if (e.key === 'Enter'){ nextStage(); }
    });
    window.addEventListener('keyup', (e)=>{ state.keys[e.key.toLowerCase()] = false; });

    btnStart.addEventListener('click', start);
    btnPause.addEventListener('click', pause);
    btnReset.addEventListener('click', reset);
    btnNextStage.addEventListener('click', nextStage);

    // Gameplay helpers
    function drawPlayer(p){
      const c = colorForSkin(state.player.skin);
      ctx.save();
      ctx.shadowColor = c; ctx.shadowBlur = 12;
      ctx.translate(p.x, p.y);
      ctx.fillStyle = c;
      ctx.strokeStyle = c;
      ctx.lineWidth = 2;
      // Diamond ship
      ctx.beginPath();
      ctx.moveTo(0,-p.h);
      ctx.lineTo(p.w,-2);
      ctx.lineTo(0, p.h);
      ctx.lineTo(-p.w,-2);
      ctx.closePath();
      ctx.fill();

      // Inner glow
      ctx.globalAlpha = 0.45;
      ctx.beginPath();
      ctx.arc(0,0,9,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;

      // Thruster
      const thruster = Math.sin(Date.now()/70)*6 + 8;
      ctx.strokeStyle = c;
      ctx.beginPath();
      ctx.moveTo(-6,p.h);
      ctx.lineTo(0,p.h+thruster);
      ctx.lineTo(6,p.h);
      ctx.stroke();
      ctx.restore();
    }

    function drawEnemy(e){
      ctx.save();
      ctx.translate(e.x,e.y);
      ctx.shadowColor = e.color; ctx.shadowBlur = 10;
      ctx.strokeStyle = e.color; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.beginPath();
      ctx.rect(-e.w/2,-e.h/2,e.w,e.h);
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }

    function drawBoss(b){
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.shadowColor = '#ff3b3b'; ctx.shadowBlur = 16;
      ctx.strokeStyle = '#ff3b3b'; ctx.lineWidth = 3; ctx.fillStyle = 'rgba(255,59,59,0.08)';
      ctx.beginPath();
      ctx.arc(0,0,b.r,0,Math.PI*2);
      ctx.fill(); ctx.stroke();
      // Eye
      ctx.beginPath();
      ctx.arc(0,0,8,0,Math.PI*2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.restore();

      // Boss HP bar (mini)
      const pct = Math.max(0,b.hp)/b.maxHP;
      const barW = 180, barH = 8;
      ctx.save();
      ctx.translate(b.x - barW/2, b.y - b.r - 16);
      ctx.fillStyle = 'rgba(10,22,49,0.85)';
      ctx.fillRect(0,0,barW,barH);
      ctx.strokeStyle = '#1e366b'; ctx.strokeRect(0,0,barW,barH);
      ctx.fillStyle = '#ff3b3b';
      ctx.shadowColor = '#ff3b3b'; ctx.shadowBlur = 10;
      ctx.fillRect(0,0,barW*pct,barH);
      ctx.restore();
    }

    function drawBullet(b){
      ctx.save();
      ctx.translate(b.x,b.y);
      ctx.shadowColor = '#ffe600'; ctx.shadowBlur = 12;
      ctx.fillStyle = '#ffe600';
      ctx.beginPath();
      ctx.arc(0,0,3,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawPickup(pu){
      ctx.save();
      ctx.translate(pu.x, pu.y);
      ctx.shadowColor = pu.type === 'energy' ? '#ffe600' : '#00ffa6';
      ctx.shadowBlur = 10;
      ctx.strokeStyle = pu.type === 'energy' ? '#ffe600' : '#00ffa6';
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.beginPath();
      ctx.arc(0,0,pu.r,0,Math.PI*2);
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }

    function drawParticles(){
      for (let i=state.particles.length-1;i>=0;i--){
        const p = state.particles[i];
        ctx.save();
        ctx.globalAlpha = Math.max(0, p.life/20);
        ctx.shadowColor = p.color; ctx.shadowBlur = 10;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x,p.y,2,2);
        ctx.restore();
        p.x += p.dx; p.y += p.dy; p.life--;
        if (p.life<=0) state.particles.splice(i,1);
      }
    }

    // Spawning
    function spawnEnemy(){
      if (state.enemies.length >= state.maxEnemiesOnScreen) return;
      const w = 18 + Math.random()*16;
      const h = 18 + Math.random()*16;
      const x = 30 + Math.random()*(WIDTH-60);
      const y = -30;
      const speed = 0.8 + Math.random()*(0.8 + 0.4*state.difficulty);
      const color = Math.random() < 0.5 ? '#00e5ff' : '#ff2ef9';
      state.enemies.push({x,y,w,h,speed,color,hp: 10+Math.floor(6*state.difficulty)});
    }

    function spawnPickup(x,y,type){
      state.pickups.push({x,y, r: 10, type, vy: 1.2});
    }

    function ambientEnergyOrb(){
      if (Math.random() < 0.04) {
        const x = 40 + Math.random()*(WIDTH-80);
        spawnPickup(x, -20, 'energy');
      }
    }

    function spawnBoss(){
      state.boss = {x: WIDTH/2, y: 120, r: 56, vx: 2.0, maxHP: 240 + 50*state.stage, hp: 240 + 50*state.stage, shootTimer:0};
    }

    // Collisions
    function rectCircleCollide(e, p){
      const pr = Math.max(p.w,p.h)/2;
      const dx = Math.abs(e.x - p.x);
      const dy = Math.abs(e.y - p.y);
      return dx < (e.w/2 + pr) && dy < (e.h/2 + pr);
    }
    function pointRectCollide(x,y,e){
      return x > e.x - e.w/2 && x < e.x + e.w/2 && y > e.y - e.h/2 && y < e.y + e.h/2;
    }
    function pointCircleCollide(x,y,pu){
      const d = Math.hypot(x - pu.x, y - pu.y);
      return d <= pu.r + 12; // radius + ship approximation
    }

    // Damage
    let shakeTime = 0;
    function damagePlayer(d){
      state.player.hp -= d;
      shakeTime = 180;
    }

    function applyShake(){
      if (shakeTime > 0){
        shakeTime -= 16;
        const sx = (Math.random()-0.5)*5;
        const sy = (Math.random()-0.5)*5;
        ctx.setTransform(1,0,0,1,sx,sy);
      } else {
        ctx.setTransform(1,0,0,1,0,0);
      }
    }

    // HUD
    function updateHUD(){
      const hpPct = Math.max(0, state.player.hp)/state.player.maxHP;
      const energyPct = Math.max(0, state.player.energy)/state.player.maxEnergy;
      hpBar.style.width = (hpPct*100)+'%';
      energyBar.style.width = (energyPct*100)+'%';
      hpText.textContent = `${Math.max(0,state.player.hp)} / ${state.player.maxHP}`;
      energyText.textContent = `${Math.floor(state.player.energy)}`;
      coinText.textContent = `${state.coins}`;
      stageText.textContent = `Stage ${state.stage}`;
    }

    // Shooting (uses energy)
    function shoot(){
      if (!state.running || state.paused) return;
      const p = state.player;
      if (p.energy < p.shootCost) return;
      p.energy -= p.shootCost;
      state.bullets.push({x:p.x, y:p.y - p.h, speed:6, damage: p.damage});
    }

    // Update
    function update(dt){
      const p = state.player;

      // Movement
      if (state.keys['w'] || state.keys['arrowup']) p.y -= p.speed;
      if (state.keys['s'] || state.keys['arrowdown']) p.y += p.speed;
      if (state.keys['a'] || state.keys['arrowleft']) p.x -= p.speed;
      if (state.keys['d'] || state.keys['arrowright']) p.x += p.speed;
      p.x = Math.max(20, Math.min(WIDTH-20, p.x));
      p.y = Math.max(40, Math.min(HEIGHT-20, p.y));

      // Spawning pacing
      state.spawnTimer += dt;
      const interval = 850 - Math.min(300, (state.stage-1)*60); // makin naik stage, sedikit lebih cepat tapi tetap seimbang
      if (!state.boss){
        if (state.spawnTimer > interval){
          state.spawnTimer = 0;
          spawnEnemy();
          ambientEnergyOrb();
        }
        // Boss trigger: setelah cukup waktu dan layar tidak terlalu penuh
        if (state.enemies.length <= 3 && Math.random() < 0.006){
          spawnBoss();
        }
      } else {
        // Boss movement
        state.boss.x += state.boss.vx;
        if (state.boss.x < 90 || state.boss.x > WIDTH-90) state.boss.vx *= -1;

        // Boss shoots rotating orbs (bullets-as-enemies)
        state.boss.shootTimer += dt;
        if (state.boss.shootTimer > 900){
          state.boss.shootTimer = 0;
          for (let i=0;i<8;i++){
            const angle = (Math.PI*2/8)*i;
            const speed = 2.2;
            const bx = state.boss.x + Math.cos(angle)*state.boss.r;
            const by = state.boss.y + Math.sin(angle)*state.boss.r;
            state.enemies.push({x:bx,y:by,w:10,h:10,speed:0.5,color:'#ff3b3b',hp:1, orb:true, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed});
          }
        }
      }

      // Enemies update
      for (let i=state.enemies.length-1;i>=0;i--){
        const e = state.enemies[i];
        if (e.orb){
          e.x += e.vx;
          e.y += e.vy;
          // bounce softly
          if (e.x<10||e.x>WIDTH-10) e.vx*=-1;
          if (e.y<10||e.y>HEIGHT-10) e.vy*=-1;
        } else {
          e.y += e.speed;
        }
        // Collision with player
        if (rectCircleCollide(e, p)){
          damagePlayer(10);
          addParticle(p.x,p.y,colorForSkin(p.skin));
          state.enemies.splice(i,1);
        } else if (e.y > HEIGHT+40){
          state.enemies.splice(i,1);
        }
      }

      // Pickups update
      for (let i=state.pickups.length-1;i>=0;i--){
        const pu = state.pickups[i];
        pu.y += pu.vy;
        if (pointCircleCollide(p.x, p.y, pu)){
          if (pu.type === 'energy'){
            p.energy = Math.min(p.maxEnergy, p.energy + 18);
          } else {
            p.hp = Math.min(p.maxHP, p.hp + 18);
          }
          addParticle(pu.x, pu.y, pu.type === 'energy' ? '#ffe600' : '#00ffa6');
          state.pickups.splice(i,1);
        } else if (pu.y > HEIGHT + 20){
          state.pickups.splice(i,1);
        }
      }

      // Bullets
      for (let i=state.bullets.length-1;i>=0;i--){
        const b = state.bullets[i];
        b.y -= b.speed;
        if (b.y < -10) { state.bullets.splice(i,1); continue; }

        // hit enemies
        let hit = false;
        for (let j=state.enemies.length-1;j>=0;j--){
          const e = state.enemies[j];
          if (pointRectCollide(b.x,b.y,e)){
            e.hp -= b.damage;
            addParticle(b.x,b.y,'#ffe600');
            state.bullets.splice(i,1);
            hit = true;
            if (e.hp <= 0){
              // drop chance: energy 35%, hp 20%
              if (!e.orb){
                const roll = Math.random();
                if (roll < 0.35) spawnPickup(e.x, e.y, 'energy');
                else if (roll < 0.55) spawnPickup(e.x, e.y, 'hp');
              }
              state.enemies.splice(j,1);
              state.coins += 2;
            }
            break;
          }
        }
        if (hit) continue;

        // hit boss
        if (state.boss){
          const dist = Math.hypot(b.x - state.boss.x, b.y - state.boss.y);
          if (dist < state.boss.r){
            state.boss.hp -= b.damage;
            addParticle(b.x,b.y,'#ff3b3b');
            state.bullets.splice(i,1);
            if (state.boss.hp <= 0){
              state.coins += 30;
              addParticle(state.boss.x,state.boss.y,'#ff3b3b');
              state.boss = null;
              state.stageClear = true;
              overlay.textContent = 'Stage Clear! Boss dikalahkan • Tekan Enter untuk lanjut';
              overlay.style.display = 'flex';
              state.paused = true;
            }
          }
        }
      }

      // Death
      if (state.player.hp <= 0){
        state.running = false;
        state.paused = true;
        overlay.textContent = 'KALAH • Tekan Reset';
        overlay.style.display = 'flex';
      }

      updateHUD();
    }

    // Grid backdrop
    function drawBackdrop(){
      ctx.save();
      for (let y=0;y<HEIGHT;y+=48){
        ctx.strokeStyle = 'rgba(0,229,255,0.06)';
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke();
      }
      for (let x=0;x<WIDTH;x+=48){
        ctx.strokeStyle = 'rgba(255,46,249,0.06)';
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke();
      }
      ctx.restore();
    }

    // Main loop
    let last = performance.now();
    function loop(now){
      const dt = now - last; last = now;
      ctx.clearRect(0,0,WIDTH,HEIGHT);
      applyShake();
      drawBackdrop();

      if (state.running && !state.paused) update(dt);

      for (const e of state.enemies) drawEnemy(e);
      for (const b of state.bullets) drawBullet(b);
      if (state.boss) drawBoss(state.boss);
      for (const pu of state.pickups) drawPickup(pu);
      drawPlayer(state.player);
      drawParticles();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Init
    reset();

  })();
  </script>
</body>
</html>
