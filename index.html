<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cartoon Colorful Bullet Arena</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        background: linear-gradient(180deg, #a8e6ff, #ffffff 40%, #ffe9b3);
        font-family: "Baloo 2", system-ui, sans-serif;
        overflow: hidden;
        color: #333;
    }
    #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
    }
    canvas {
        display: block;
        margin: 0 auto;
        background:
            radial-gradient(circle at 10% 20%, #fff3c4 0, transparent 40%),
            radial-gradient(circle at 90% 10%, #ffd4f0 0, transparent 40%),
            radial-gradient(circle at 20% 90%, #c2f7ff 0, transparent 45%),
            #fdf7ff;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.18);
    }

    /* UI overlay */
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        display: flex;
        justify-content: space-between;
        pointer-events: none;
    }
    #leftUI, #rightUI {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .barContainer {
        width: 220px;
        height: 20px;
        border-radius: 999px;
        border: 3px solid #ff7b7b;
        background: #ffe5e5;
        position: relative;
        overflow: hidden;
    }
    .barFill {
        height: 100%;
        background: linear-gradient(90deg, #ff9a9a, #ffd27f);
        width: 100%;
        border-radius: 999px;
        transition: width 0.15s;
    }
    .barLabel {
        position: absolute;
        top: 50%;
        left: 10px;
        transform: translateY(-50%);
        font-size: 12px;
        font-weight: 600;
        color: #b02c2c;
    }

    .pillInfo {
        font-size: 13px;
        font-weight: 600;
        background: #ffffffcc;
        padding: 4px 10px;
        border-radius: 999px;
        border: 2px solid #ffd27f;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    /* Shop button (keranjang kartun) */
    #shopButton {
        pointer-events: auto;
        width: 46px;
        height: 46px;
        border-radius: 14px;
        border: 3px solid #ffb64c;
        background: #fff7e5;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        transition: transform 0.1s, box-shadow 0.1s;
    }
    #shopButton:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0,0,0,0.2);
    }
    #shopButton::before {
        content: "";
        width: 22px;
        height: 14px;
        border-radius: 4px 4px 8px 8px;
        border: 3px solid #ffb64c;
        border-top: 0;
        box-shadow: inset 0 3px 0 #ffb64c;
        background: #ffe0a3;
    }
    #shopButton::after {
        content: "";
        position: absolute;
        top: 10px;
        width: 18px;
        height: 3px;
        background: #ffb64c;
        border-radius: 999px;
    }

    /* Shop panel */
    #shopPanel {
        position: absolute;
        right: 20px;
        top: 70px;
        width: 280px;
        background: #ffffffee;
        border-radius: 18px;
        border: 3px solid #ffb64c;
        padding: 10px 12px 12px;
        display: none;
        pointer-events: auto;
        box-shadow: 0 8px 20px rgba(0,0,0,0.18);
    }
    #shopTitle {
        font-size: 18px;
        font-weight: 700;
        color: #f27b35;
        margin-bottom: 6px;
        display: flex;
        align-items: center;
        gap: 6px;
    }
    #shopTitle::before {
        content: "ðŸ›’";
    }
    .shopSectionTitle {
        font-size: 13px;
        margin: 8px 0 4px;
        color: #ff8b5c;
        font-weight: 700;
    }
    .shopGrid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
    }
    .shopItem {
        border-radius: 12px;
        border: 2px solid #ffd6a5;
        padding: 4px 6px;
        font-size: 11px;
        background: #fffaf1;
        cursor: pointer;
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 2px;
        transition: transform 0.08s, box-shadow 0.08s, border-color 0.08s;
    }
    .shopItem:hover {
        border-color: #ffb64c;
        box-shadow: 0 3px 7px rgba(0,0,0,0.15);
        transform: translateY(-1px);
    }
    .shopItemTitle {
        font-weight: 700;
        color: #ff7b7b;
    }
    .shopItemCost {
        color: #f29f05;
        font-size: 10px;
        font-weight: 700;
    }
    .shopItemDesc {
        font-size: 10px;
        color: #666;
    }
    .skinPreview {
        width: 26px;
        height: 26px;
        border-radius: 50%;
        border: 3px solid #fff;
        box-shadow: 0 0 0 2px #ffd6a5;
        margin-bottom: 2px;
    }
    .equippedTag {
        position: absolute;
        top: 3px;
        right: 3px;
        background: #96f28b;
        color: #2b6c1f;
        font-size: 9px;
        font-weight: 700;
        padding: 1px 4px;
        border-radius: 999px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    }

    /* Boss warning */
    #bossWarning {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.45);
        color: #fff;
        font-size: 34px;
        font-weight: 900;
        letter-spacing: 2px;
        text-shadow: 0 0 10px #ff5a5a;
        pointer-events: none;
        animation: warningBounce 1s infinite;
    }
    @keyframes warningBounce {
        0% { transform: scale(0.9); opacity: 0.1; }
        40% { transform: scale(1.05); opacity: 1; }
        100% { transform: scale(1); opacity: 0; }
    }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="960" height="540"></canvas>

    <div id="ui">
        <div id="leftUI">
            <div class="barContainer">
                <div id="hpFill" class="barFill"></div>
                <div class="barLabel">HP</div>
            </div>
            <div class="pillInfo" id="coinDisplay">ðŸ’° 0</div>
            <div class="pillInfo" id="waveDisplay">Wave 1</div>
            <div class="pillInfo" id="spawnDisplay">Spawn: 0.0s</div>
        </div>
        <div id="rightUI">
            <div class="pillInfo" id="statDisplay">DMG 0 | FR 0ms</div>
            <div id="shopButton" title="Open Shop"></div>
        </div>
    </div>

    <div id="shopPanel">
        <div id="shopTitle">Shop</div>

        <div class="shopSectionTitle">Upgrades (Permanent)</div>
        <div class="shopGrid">
            <div class="shopItem" data-type="upgrade" data-upgrade="hp">
                <div class="shopItemTitle">Heart Boost</div>
                <div class="shopItemCost">Cost: 50+</div>
                <div class="shopItemDesc">Max HP +20</div>
            </div>
            <div class="shopItem" data-type="upgrade" data-upgrade="damage">
                <div class="shopItemTitle">Power Shot</div>
                <div class="shopItemCost">Cost: 60+</div>
                <div class="shopItemDesc">Damage +5</div>
            </div>
            <div class="shopItem" data-type="upgrade" data-upgrade="fireRate">
                <div class="shopItemTitle">Rapid Fun</div>
                <div class="shopItemCost">Cost: 70+</div>
                <div class="shopItemDesc">Shoot faster!</div>
            </div>
        </div>

        <div class="shopSectionTitle">Skins</div>
        <div class="shopGrid">
            <div class="shopItem" data-type="skin" data-skin="default">
                <div class="skinPreview" style="background: radial-gradient(circle at 30% 30%, #fff 0, #ff7b7b 40%, #ff4c4c 70%);"></div>
                <div class="shopItemTitle">Cherry Puff</div>
                <div class="shopItemCost">Owned</div>
                <div class="shopItemDesc">Default cute hero</div>
                <div class="equippedTag">EQUIPPED</div>
            </div>
            <div class="shopItem" data-type="skin" data-skin="mint">
                <div class="skinPreview" style="background: radial-gradient(circle at 30% 30%, #fff 0, #98ffb3 40%, #53d88a 70%);"></div>
                <div class="shopItemTitle">Mint Buddy</div>
                <div class="shopItemCost">Cost: 120</div>
                <div class="shopItemDesc">Fresh green style</div>
            </div>
            <div class="shopItem" data-type="skin" data-skin="bubble">
                <div class="skinPreview" style="background: radial-gradient(circle at 30% 30%, #fff 0, #8fd1ff 40%, #4aa6ff 70%);"></div>
                <div class="shopItemTitle">Bubble Pop</div>
                <div class="shopItemCost">Cost: 120</div>
                <div class="shopItemDesc">Blue bubbly hero</div>
            </div>
            <div class="shopItem" data-type="skin" data-skin="secret">
                <div class="skinPreview" style="background: conic-gradient(#ff9a9a,#ffe174,#a2ff9e,#8fd1ff,#ff9aeb,#ff9a9a);"></div>
                <div class="shopItemTitle">Secret Buddy</div>
                <div class="shopItemCost">Drop Only</div>
                <div class="shopItemDesc">Bonus stats included</div>
            </div>
        </div>
    </div>

    <div id="bossWarning">BOSS TIME!</div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const hpFill = document.getElementById("hpFill");
const coinDisplay = document.getElementById("coinDisplay");
const waveDisplay = document.getElementById("waveDisplay");
const spawnDisplay = document.getElementById("spawnDisplay");
const statDisplay = document.getElementById("statDisplay");

const shopButton = document.getElementById("shopButton");
const shopPanel = document.getElementById("shopPanel");
const bossWarning = document.getElementById("bossWarning");
const shopItems = document.querySelectorAll(".shopItem");

// WORLD
const world = {
    width: canvas.width,
    height: canvas.height,
    wave: 1,
    coins: 0,
    spawnCooldown: 1800,
    nextSpawnTime: 0,
    enemiesPerWave: 12,
    enemiesSpawned: 0,
    enemiesKilled: 0,
    bossActive: false,
    inBossTransition: false
};

// PLAYER
const player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    radius: 16,

    baseMaxHp: 100,
    baseDamage: 10,
    baseFireRate: 900,
    speed: 3.7,

    maxHp: 100,
    hp: 100,
    damage: 10,
    fireRate: 900,

    upgrades: {
        hp: 0,
        damage: 0,
        fireRate: 0
    },

    skin: "default"
};

let bullets = [];         // peluru player
let enemyBullets = [];    // peluru musuh & bos
let enemies = [];
let items = [];
let boss = null;

let lastShotTime = 0;
let lastFrameTime = 0;

let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;

const keys = {};

// INPUT
document.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === "Escape") shopPanel.style.display = "none";
});
document.addEventListener("keyup", e => {
    keys[e.key.toLowerCase()] = false;
});

canvas.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

// SHOP
shopButton.addEventListener("click", () => {
    shopPanel.style.display = shopPanel.style.display === "none" ? "block" : "none";
});

shopItems.forEach(el => {
    el.addEventListener("click", () => {
        const type = el.dataset.type;
        if (type === "upgrade") buyUpgrade(el.dataset.upgrade);
        else if (type === "skin") buySkin(el.dataset.skin, el);
    });
});

function applyUpgrades() {
    player.maxHp = player.baseMaxHp + player.upgrades.hp * 20;
    player.hp = Math.min(player.hp, player.maxHp);
    player.damage = player.baseDamage + player.upgrades.damage * 5;
    player.fireRate = Math.max(150, player.baseFireRate - player.upgrades.fireRate * 70);
}

function buyUpgrade(type) {
    let cost = 0;
    if (type === "hp") cost = 50 + player.upgrades.hp * 15;
    if (type === "damage") cost = 60 + player.upgrades.damage * 18;
    if (type === "fireRate") cost = 70 + player.upgrades.fireRate * 20;

    if (world.coins >= cost) {
        world.coins -= cost;
        player.upgrades[type]++;
        applyUpgrades();
    }
}

function clearEquippedTag() {
    document.querySelectorAll(".equippedTag").forEach(e => e.remove());
}
function markEquippedSkin(name) {
    clearEquippedTag();
    document.querySelectorAll(`.shopItem[data-type="skin"]`).forEach(el => {
        if (el.dataset.skin === name) {
            const tag = document.createElement("div");
            tag.className = "equippedTag";
            tag.textContent = "EQUIPPED";
            el.appendChild(tag);
        }
    });
}

function buySkin(skinName, el) {
    if (skinName === "default") {
        player.skin = "default";
        markEquippedSkin("default");
        return;
    }
    if (skinName === "secret") {
        return; // cuma dari drop
    }
    const costEl = el.querySelector(".shopItemCost");
    if (costEl && costEl.textContent.includes("Owned")) {
        player.skin = skinName;
        markEquippedSkin(skinName);
        return;
    }
    const cost = 120;
    if (world.coins >= cost) {
        world.coins -= cost;
        if (costEl) costEl.textContent = "Owned";
        player.skin = skinName;
        markEquippedSkin(skinName);
    }
}

// MOVEMENT
function movePlayer(delta) {
    const vel = player.speed * (delta / 16.67);
    if (keys["w"]) player.y -= vel;
    if (keys["s"]) player.y += vel;
    if (keys["a"]) player.x -= vel;
    if (keys["d"]) player.x += vel;

    player.x = Math.max(player.radius, Math.min(world.width - player.radius, player.x));
    player.y = Math.max(player.radius, Math.min(world.height - player.radius, player.y));
}

// AUTO-SHOOT
function autoShoot(timestamp) {
    if (timestamp - lastShotTime >= player.fireRate) {
        shootBullet();
        lastShotTime = timestamp;
    }
}
function shootBullet() {
    const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
    const speed = 8;
    bullets.push({
        x: player.x,
        y: player.y,
        dx: Math.cos(angle) * speed,
        dy: Math.sin(angle) * speed,
        radius: 4,
        damage: player.damage,
        friendly: true
    });
}

// ENEMY & BOSS SHOOT
function enemyShoot(e) {
    const angle = Math.atan2(player.y - e.y, player.x - e.x);
    const speed = 3;
    enemyBullets.push({
        x: e.x,
        y: e.y,
        dx: Math.cos(angle) * speed,
        dy: Math.sin(angle) * speed,
        radius: 4,
        damage: 6,
        friendly: false,
        color: "#ff9a9a"
    });
}
function bossShootSpread(b) {
    const base = Math.atan2(player.y - b.y, player.x - b.x);
    const count = 7;
    const spread = 0.9;
    for (let i = 0; i < count; i++) {
        const angle = base - spread/2 + (spread/(count-1))*i;
        const speed = 3.3;
        enemyBullets.push({
            x: b.x,
            y: b.y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            radius: 5,
            damage: 8,
            friendly: false,
            color: "#ff9af2"
        });
    }
}

// ENEMY / BOSS SPAWN
function spawnEnemy() {
    const margin = 40;
    const side = Math.floor(Math.random() * 4);
    let x, y;
    if (side === 0) { x = Math.random() * world.width; y = -margin; }
    if (side === 1) { x = world.width + margin; y = Math.random() * world.height; }
    if (side === 2) { x = Math.random() * world.width; y = world.height + margin; }
    if (side === 3) { x = -margin; y = Math.random() * world.height; }

    const typeRand = Math.random();
    let hp = 24 + world.wave * 2;
    let speed = 1.4 + world.wave * 0.05;
    let color = "#ffb5b5";
    let shootCooldown = 2000 + Math.random() * 800;

    if (typeRand < 0.35) {
        hp -= 4;
        speed += 0.6;
        color = "#ffd27f";
        shootCooldown += 400;
    } else if (typeRand > 0.7) {
        hp += 15;
        speed -= 0.4;
        color = "#b5e48c";
        shootCooldown -= 300;
    }

    enemies.push({
        x, y,
        radius: 15,
        hp,
        maxHp: hp,
        speed,
        color,
        isBoss: false,
        nextShot: performance.now() + shootCooldown,
        shootCooldownBase: shootCooldown
    });
}

function spawnBoss() {
    const hpBase = 450;
    const hp = hpBase + world.wave * 120; // makin tebal tiap wave
    boss = {
        x: world.width / 2,
        y: 130,
        radius: 46,
        hp,
        maxHp: hp,
        speed: 1.4,
        phase: 1,
        phaseTimer: 0,
        nextShot: performance.now() + 1000,
        shootInterval: Math.max(900, 1600 - world.wave * 60),
        isBoss: true
    };
    world.bossActive = true;
}

// ITEMS
function spawnItem(x, y, type) {
    const colors = {
        heal: "#ff9a9a",
        fireRate: "#8fd1ff",
        damage: "#ffd27f",
        speed: "#b5e48c",
        coin: "#ffbf69",
        secretUnit: "#ff9af2"
    };
    items.push({
        x, y,
        radius: 9,
        type,
        color: colors[type] || "#ffffff",
        pulse: 0
    });
}

// PROGRESSION
function startBossTransition() {
    world.inBossTransition = true;
    bossWarning.style.display = "flex";
    setTimeout(() => {
        bossWarning.style.display = "none";
        world.inBossTransition = false;
        spawnBoss();
    }, 2000);
}

function updateSpawn(timestamp) {
    if (world.bossActive || world.inBossTransition) {
        spawnDisplay.textContent = "Boss Stage";
        return;
    }

    if (world.enemiesSpawned >= world.enemiesPerWave) {
        if (enemies.length === 0 && !world.bossActive && !world.inBossTransition) {
            startBossTransition();
        }
        return;
    }

    if (timestamp >= world.nextSpawnTime) {
        spawnEnemy();
        world.enemiesSpawned++;
        world.spawnCooldown = Math.max(450, world.spawnCooldown - 40); // makin cepat
        world.nextSpawnTime = timestamp + world.spawnCooldown;
    }

    const remaining = Math.max(0, world.nextSpawnTime - timestamp);
    spawnDisplay.textContent = "Spawn: " + (remaining / 1000).toFixed(1) + "s";
}

// HELPERS
function dist2(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx*dx + dy*dy;
}

// BULLET UPDATE
function updateBullets(delta, timestamp) {
    // player bullets
    const toRemove = new Set();
    bullets.forEach((b, i) => {
        b.x += b.dx * (delta / 16.67);
        b.y += b.dy * (delta / 16.67);
        if (b.x < -30 || b.x > world.width + 30 || b.y < -30 || b.y > world.height + 30) {
            toRemove.add(i);
            return;
        }
        // hit enemies
        enemies.forEach((e, j) => {
            if (dist2(b.x, b.y, e.x, e.y) < (b.radius + e.radius) ** 2) {
                e.hp -= b.damage;
                toRemove.add(i);
                if (e.hp <= 0) {
                    world.enemiesKilled++;
                    world.coins += 6;
                    if (Math.random() < 0.25) spawnItem(e.x, e.y, "heal");
                    if (Math.random() < 0.25) spawnItem(e.x, e.y, "coin");
                    if (Math.random() < 0.13) spawnItem(e.x, e.y, "damage");
                    if (Math.random() < 0.08) spawnItem(e.x, e.y, "fireRate");
                    if (Math.random() < 0.06) spawnItem(e.x, e.y, "speed");
                    enemies.splice(j, 1);
                }
            }
        });
        // hit boss
        if (boss && dist2(b.x, b.y, boss.x, boss.y) < (b.radius + boss.radius) ** 2) {
            boss.hp -= b.damage;
            toRemove.add(i);
            if (boss.hp <= 0) {
                world.coins += 150;
                if (Math.random() < 0.6) spawnItem(boss.x, boss.y, "secretUnit");
                boss = null;
                world.bossActive = false;
                nextWave();
            }
        }
    });
    bullets = bullets.filter((_, idx) => !toRemove.has(idx));

    // enemy bullets
    const toRemoveEnemy = new Set();
    enemyBullets.forEach((b, i) => {
        b.x += b.dx * (delta / 16.67);
        b.y += b.dy * (delta / 16.67);
        if (b.x < -40 || b.x > world.width + 40 || b.y < -40 || b.y > world.height + 40) {
            toRemoveEnemy.add(i);
            return;
        }
        if (dist2(b.x, b.y, player.x, player.y) < (b.radius + player.radius) ** 2) {
            player.hp -= b.damage;
            toRemoveEnemy.add(i);
            if (player.hp <= 0) resetGame();
        }
    });
    enemyBullets = enemyBullets.filter((_, idx) => !toRemoveEnemy.has(idx));
}

// ENEMY & BOSS UPDATE
function updateEnemies(delta, timestamp) {
    enemies.forEach(e => {
        const angle = Math.atan2(player.y - e.y, player.x - e.x);
        const vel = e.speed * (delta / 16.67);
        e.x += Math.cos(angle) * vel;
        e.y += Math.sin(angle) * vel;

        // enemy shooting
        if (timestamp >= e.nextShot) {
            enemyShoot(e);
            e.nextShot = timestamp + e.shootCooldownBase;
        }

        if (dist2(e.x, e.y, player.x, player.y) < (e.radius + player.radius) ** 2) {
            player.hp -= 0.25 * (delta / 16.67);
            if (player.hp <= 0) resetGame();
        }
    });

    if (boss) {
        boss.phaseTimer += delta;
        const vel = boss.speed * (delta / 16.67);
        if (boss.phase === 1) {
            boss.x = world.width / 2 + Math.sin(boss.phaseTimer * 0.0025) * 160;
        } else {
            const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
            boss.x += Math.cos(angle) * vel;
            boss.y += Math.sin(angle) * vel * 0.7;
        }
        if (boss.hp < boss.maxHp * 0.5) boss.phase = 2;

        if (timestamp >= boss.nextShot) {
            bossShootSpread(boss);
            boss.nextShot = timestamp + boss.shootInterval;
        }

        if (dist2(boss.x, boss.y, player.x, player.y) < (boss.radius + player.radius) ** 2) {
            player.hp -= 0.55 * (delta / 16.67);
            if (player.hp <= 0) resetGame();
        }
    }
}

// ITEMS UPDATE
function updateItems(delta) {
    items.forEach(it => {
        it.pulse += delta * 0.005;
        if (dist2(it.x, it.y, player.x, player.y) < (it.radius + player.radius) ** 2 + 50) {
            const angle = Math.atan2(player.y - it.y, player.x - it.x);
            const vel = 2.6 * (delta / 16.67);
            it.x += Math.cos(angle) * vel;
            it.y += Math.sin(angle) * vel;
        }
    });

    for (let i = items.length - 1; i >= 0; i--) {
        const it = items[i];
        if (dist2(it.x, it.y, player.x, player.y) < (it.radius + player.radius) ** 2) {
            if (it.type === "heal") {
                player.hp = Math.min(player.maxHp, player.hp + 30);
            } else if (it.type === "coin") {
                world.coins += 18;
            } else if (it.type === "damage") {
                player.damage += 4;
            } else if (it.type === "fireRate") {
                player.fireRate = Math.max(130, player.fireRate - 110);
            } else if (it.type === "speed") {
                player.speed += 0.35;
            } else if (it.type === "secretUnit") {
                player.baseMaxHp += 30;
                player.baseDamage += 6;
                player.speed += 0.3;
                player.skin = "secret";
                markEquippedSkin("secret");
                applyUpgrades();
            }
            items.splice(i, 1);
        }
    }
}

// WAVE
function nextWave() {
    world.wave++;
    world.enemiesPerWave += 6;
    world.enemiesSpawned = 0;
    world.enemiesKilled = 0;
    world.spawnCooldown = Math.max(450, 1800 - world.wave * 90);
    world.nextSpawnTime = performance.now() + 1500;
}

// RESET
function resetGame() {
    enemies = [];
    bullets = [];
    enemyBullets = [];
    items = [];
    boss = null;

    player.hp = player.maxHp;
    player.x = world.width / 2;
    player.y = world.height / 2;

    world.wave = 1;
    world.enemiesPerWave = 12;
    world.enemiesSpawned = 0;
    world.enemiesKilled = 0;
    world.spawnCooldown = 1800;
    world.nextSpawnTime = performance.now() + 1000;
    world.bossActive = false;
    world.inBossTransition = false;
}

// DRAW
function drawBackgroundFun() {
    ctx.save();
    ctx.globalAlpha = 0.12;
    for (let i = 0; i < 6; i++) {
        const x = (i * 180 + performance.now() * 0.02) % (canvas.width + 200) - 100;
        const y = 60 + (i % 3) * 120;
        ctx.beginPath();
        ctx.ellipse(x, y, 90, 30, 0, 0, Math.PI * 2);
        ctx.fillStyle = ["#ffe9b3","#ffd6f4","#c2f2ff"][i % 3];
        ctx.fill();
    }
    ctx.restore();
}

function drawPlayer() {
    let grad;
    if (player.skin === "default") {
        grad = ctx.createRadialGradient(player.x-4, player.y-4, 3, player.x, player.y, player.radius+2);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.4, "#ff9a9a");
        grad.addColorStop(1, "#ff4c4c");
    } else if (player.skin === "mint") {
        grad = ctx.createRadialGradient(player.x-4, player.y-4, 3, player.x, player.y, player.radius+2);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.4, "#b5f8c5");
        grad.addColorStop(1, "#53d88a");
    } else if (player.skin === "bubble") {
        grad = ctx.createRadialGradient(player.x-4, player.y-4, 3, player.x, player.y, player.radius+2);
        grad.addColorStop(0, "#fff");
        grad.addColorStop(0.4, "#b3e0ff");
        grad.addColorStop(1, "#4aa6ff");
    } else if (player.skin === "secret") {
        grad = ctx.createRadialGradient(player.x-4, player.y-4, 3, player.x, player.y, player.radius+2);
        grad.addColorStop(0, "#ffffff");
        grad.addColorStop(0.4, "#ffe174");
        grad.addColorStop(0.7, "#a2ff9e");
        grad.addColorStop(1, "#ff9af2");
    }

    ctx.save();
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius + 6, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,0.09)";
    ctx.fill();
    ctx.restore();

    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#ffffffcc";
    ctx.stroke();

    const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
    ctx.beginPath();
    ctx.arc(player.x + Math.cos(angle) * 9, player.y + Math.sin(angle) * 9, 4, 0, Math.PI*2);
    ctx.fillStyle = "#fff";
    ctx.fill();
}

function drawBullets() {
    bullets.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.beginPath();
        ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#ffd27f";
        ctx.fill();
        ctx.strokeStyle = "#ffb64c";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    });

    enemyBullets.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.beginPath();
        ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
        ctx.fillStyle = b.color || "#ff9a9a";
        ctx.fill();
        ctx.strokeStyle = "#ffffffdd";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    });
}

function drawEnemies() {
    enemies.forEach(e => {
        ctx.save();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
        ctx.fillStyle = e.color;
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#ffffffcc";
        ctx.stroke();
        ctx.restore();

        const w = 26;
        const h = 4;
        const pct = e.hp / e.maxHp;
        ctx.fillStyle = "#ffffffdd";
        ctx.fillRect(e.x - w/2, e.y - e.radius - 9, w, h);
        ctx.fillStyle = "#ff7b7b";
        ctx.fillRect(e.x - w/2, e.y - e.radius - 9, w * pct, h);
        ctx.strokeStyle = "#e28b8b";
        ctx.lineWidth = 1;
        ctx.strokeRect(e.x - w/2, e.y - e.radius - 9, w, h);
    });

    if (boss) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI*2);
        const grad = ctx.createRadialGradient(boss.x-8,boss.y-10,5,boss.x,boss.y,boss.radius+8);
        grad.addColorStop(0,"#fff");
        grad.addColorStop(0.4,"#ff9aeb");
        grad.addColorStop(1,"#ff5a99");
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = "#ffffffdd";
        ctx.stroke();
        ctx.restore();

        const w = canvas.width * 0.6;
        const h = 14;
        const pct = boss.hp / boss.maxHp;
        const x = (canvas.width - w) / 2;
        const y = 18;

        ctx.fillStyle = "#ffffffdd";
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = "#ff7b7b";
        ctx.fillRect(x, y, w * pct, h);
        ctx.strokeStyle = "#ff5a5a";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);
    }
}

function drawItems() {
    items.forEach(it => {
        const scale = 1 + Math.sin(it.pulse) * 0.16;
        ctx.save();
        ctx.translate(it.x, it.y);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.arc(0, 0, it.radius + 3, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.6)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(0, 0, it.radius, 0, Math.PI * 2);
        ctx.fillStyle = it.color;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#ffffffdd";
        ctx.stroke();
        ctx.restore();
    });
}

// UI
function updateUI() {
    const hpPct = Math.max(0, player.hp / player.maxHp);
    hpFill.style.width = (hpPct * 100) + "%";
    coinDisplay.textContent = "ðŸ’° " + Math.floor(world.coins);
    waveDisplay.textContent = "Wave " + world.wave;
    statDisplay.textContent = "DMG " + player.damage + " | FR " + Math.floor(player.fireRate) + "ms";
}

// MAIN LOOP
function gameLoop(timestamp) {
    if (!lastFrameTime) lastFrameTime = timestamp;
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackgroundFun();

    movePlayer(delta);
    autoShoot(timestamp);
    updateSpawn(timestamp);
    updateBullets(delta, timestamp);
    updateEnemies(delta, timestamp);
    updateItems(delta);

    drawBullets();
    drawEnemies();
    drawItems();
    drawPlayer();

    updateUI();

    requestAnimationFrame(gameLoop);
}

// INIT
resetGame();
applyUpgrades();
markEquippedSkin("default");
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
