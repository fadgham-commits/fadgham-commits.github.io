<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"/>
  <title>Pulsefall — Reflex Arcade</title>
  <style>
    :root {
      --bg:#0a0d12; --fg:#eaf1ff; --accent:#6cf; --accent2:#c6f;
      --danger:#ff5e7a; --safe:#2df; --shadow:#0c1219;
    }
    html,body{margin:0;height:100%;background:radial-gradient(1200px at 50% 75%,#0f1320,#090b12 60%,#07080c);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:var(--fg);}
    canvas{display:block; width:100vw; height:100vh; touch-action:none;}
    .hud{
      position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; justify-content:space-between;
      padding:16px; mix-blend-mode:screen;
    }
    .top, .bottom{display:flex; justify-content:space-between; align-items:center;}
    .chip{background:rgba(128,160,255,.12); backdrop-filter: blur(6px);
      border:1px solid rgba(128,160,255,.25); border-radius:12px; padding:8px 12px; box-shadow: 0 0 24px rgba(102,204,255,.15);}
    .title{font-weight:700; letter-spacing:.6px;}
    .bar{height:8px; width:180px; background:rgba(255,255,255,.06); border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.12);}
    .fill{height:100%; background:linear-gradient(90deg, var(--accent), var(--accent2)); box-shadow:0 0 14px var(--accent);}
    .center{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
      text-align:center; padding:24px;
    }
    .card{
      pointer-events:auto; max-width:560px; width:90%; background:rgba(12,16,28,.7); border:1px solid rgba(128,160,255,.25);
      border-radius:16px; padding:16px 18px; box-shadow:0 24px 80px rgba(8,12,20,.6);
      animation:pop .4s ease-out both;
    }
    .card h1{margin:10px 0 8px; font-size:28px;}
    .card p{margin:10px 0; color:#cfe6ff;}
    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .btn{cursor:pointer; padding:10px 14px; border-radius:12px; border:1px solid rgba(128,160,255,.35);
      background:linear-gradient(180deg, rgba(90,140,255,.2), rgba(90,140,255,.06)); color:#eaf1ff; font-weight:600;}
    .btn.primary{background:linear-gradient(180deg, rgba(90,140,255,.55), rgba(90,140,255,.25)); box-shadow:0 12px 40px rgba(90,140,255,.35);}
    .kbd{display:inline-block; border:1px solid rgba(255,255,255,.2); border-radius:6px; padding:2px 6px; background:rgba(255,255,255,.08);}
    @keyframes pop{from{transform:translateY(8px) scale(.98); opacity:0} to{transform:none; opacity:1}}
    /* mobile controls */
    .controls{position:fixed; inset:auto 0 14px 0; display:flex; justify-content:center; gap:12px; pointer-events:auto;}
    .ctl{width:72px; height:72px; border-radius:999px; border:1px solid rgba(128,160,255,.35);
      background:radial-gradient(180px at 30% 30%, rgba(90,140,255,.4), rgba(90,140,255,.08)); color:#eaf1ff; font-weight:700;
      display:flex; align-items:center; justify-content:center; box-shadow:0 12px 40px rgba(90,140,255,.25);}
    .ctl.big{width:96px; height:96px;}
    @media (min-width:800px){ .controls{display:none;} }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud">
    <div class="top">
      <div class="chip title">Pulsefall</div>
      <div class="chip">Skor: <span id="score">0</span></div>
      <div class="chip">Combo: <span id="combo">x1.0</span></div>
      <div class="chip">
        Energi
        <div class="bar"><div id="energy" class="fill" style="width:0%"></div></div>
      </div>
    </div>
    <div class="bottom">
      <div class="chip">Waktu: <span id="time">0.0s</span></div>
      <div class="chip">Kecepatan: <span id="spd">1.00x</span></div>
      <div class="chip">Phase: <span id="phase">Ready</span></div>
    </div>
  </div>
  <div class="center" id="overlay">
    <div class="card">
      <h1>Pulsefall</h1>
      <p>Bertahan di hujan rintangan, serap pulse, dan aktifkan <strong>Phase Shift</strong> untuk nembus realitas sejenak.</p>
      <p><strong>Kontrol:</strong> <span class="kbd">A/D</span> atau <span class="kbd">←/→</span>, <span class="kbd">Spasi</span> (Dash), <span class="kbd">Shift</span> (Phase)</p>
      <div class="btns">
        <button class="btn primary" id="start">Mulai</button>
        <button class="btn" id="mute">Suara: On</button>
      </div>
    </div>
  </div>
  <div class="controls">
    <button class="ctl" id="left">←</button>
    <button class="ctl big" id="dash">Dash</button>
    <button class="ctl" id="right">→</button>
    <button class="ctl big" id="phaseBtn">Phase</button>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W=0,H=0, DPR= Math.min(2, window.devicePixelRatio||1);
    function resize(){
      W = canvas.clientWidth = window.innerWidth;
      H = canvas.clientHeight = window.innerHeight;
      canvas.width = W * DPR; canvas.height = H * DPR;
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener('resize', resize); resize();

    // HUD elements
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const energyEl = document.getElementById('energy');
    const timeEl = document.getElementById('time');
    const spdEl = document.getElementById('spd');
    const phaseEl = document.getElementById('phase');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start');
    const muteBtn = document.getElementById('mute');

    // Mobile controls
    const leftBtn = document.getElementById('left');
    const rightBtn = document.getElementById('right');
    const dashBtn = document.getElementById('dash');
    const phaseBtn = document.getElementById('phaseBtn');

    // Game state
    const state = {
      running:false,
      t:0, score:0, combo:1, comboTime:0,
      speed:1, baseSpeed:1, maxSpeed:2.4,
      player:{x:0, y:0, vx:0, w:26, h:26, iFrames:0, alive:true},
      energy:0, energyMax:100,
      phase:0, phaseMax:1500, phaseCD:0,
      pulses:[], obstacles:[], sparks:[], trails:[],
      input:{left:false, right:false, dash:false, phase:false, mx:null},
      audioOn:true,
    };

    // Simple audio using WebAudio
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    let masterGain = audioCtx.createGain(); masterGain.gain.value = .2; masterGain.connect(audioCtx.destination);
    function beep(freq=440, dur=0.08, type='sine', vol=.15){
      if(!state.audioOn) return;
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=vol;
      o.connect(g); g.connect(masterGain);
      o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+dur);
      o.stop(audioCtx.currentTime+dur);
    }

    // Utils
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a=0,b=1)=>a+Math.random()*(b-a);
    const chance = p=>Math.random()<p;
    function rectOverlap(a,b){return Math.abs(a.x-b.x) < (a.w+b.w)/2 && Math.abs(a.y-b.y) < (a.h+b.h)/2;}

    // Input handlers
    window.addEventListener('keydown', (e)=>{
      if(e.repeat) return;
      if(e.key==='a'||e.key==='ArrowLeft') state.input.left=true;
      if(e.key==='d'||e.key==='ArrowRight') state.input.right=true;
      if(e.key===' '){ state.input.dash=true; e.preventDefault();}
      if(e.key==='Shift'){ state.input.phase=true; e.preventDefault();}
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key==='a'||e.key==='ArrowLeft') state.input.left=false;
      if(e.key==='d'||e.key==='ArrowRight') state.input.right=false;
    });
    canvas.addEventListener('pointerdown', e=>{
      state.input.mx = e.clientX;
    });
    canvas.addEventListener('pointermove', e=>{
      if(state.input.mx!==null){ state.player.x = clamp(e.clientX, 40, W-40); }
    });
    canvas.addEventListener('pointerup', ()=> state.input.mx=null);

    leftBtn.addEventListener('pointerdown', ()=> state.input.left=true);
    leftBtn.addEventListener('pointerup', ()=> state.input.left=false);
    rightBtn.addEventListener('pointerdown', ()=> state.input.right=true);
    rightBtn.addEventListener('pointerup', ()=> state.input.right=false);
    dashBtn.addEventListener('click', ()=> state.input.dash=true);
    phaseBtn.addEventListener('click', ()=> state.input.phase=true);

    startBtn.addEventListener('click', ()=>{
      overlay.style.display='none';
      reset();
      state.running = true;
      audioCtx.resume();
    });
    muteBtn.addEventListener('click', ()=>{
      state.audioOn = !state.audioOn;
      muteBtn.textContent = `Suara: ${state.audioOn?'On':'Off'}`;
      if(state.audioOn) beep(660,.06,'sine',.12);
    });

    function reset(){
      state.t=0; state.score=0; state.combo=1; state.comboTime=0;
      state.speed=state.baseSpeed; state.player.alive=true; state.player.iFrames=0;
      state.energy=0; state.phase=0; state.phaseCD=0;
      state.pulses.length=0; state.obstacles.length=0; state.sparks.length=0; state.trails.length=0;
      state.player.x = W/2; state.player.y = H*0.75; state.player.vx=0;
    }

    // Spawner
    function spawn(){
      // difficulty scales with time
      const t = state.t;
      const laneW = Math.max(80, W/8);
      const gap = clamp(120 - t*0.015, 60, 120);
      if(chance(0.9)){
        // obstacle line
        const count = chance(0.6)? 3 : 2;
        const baseY = -40;
        for(let i=0;i<count;i++){
          const o = {x: rand(40, W-40), y: baseY - i*rand(40, 120), w: rand(26, 44), h: rand(26, 44), vy: rand(1.2, 2.4)};
          state.obstacles.push(o);
        }
      }
      if(chance(0.6)){
        // pulses
        const p = {x: rand(40, W-40), y: -20, w:22, h:22, vy: rand(1.3, 2.2), type: chance(0.75)?'energy':'score'};
        state.pulses.push(p);
      }
      // speed ramp
      state.speed = clamp(state.baseSpeed + t*0.0006, state.baseSpeed, state.maxSpeed);
    }

    // Effects
    function addSpark(x,y,color){
      state.sparks.push({x,y,vx:rand(-1.2,1.2),vy:rand(-1.2,1.2),life:rand(220,360),color});
    }
    function addTrail(x,y){
      state.trails.push({x,y,life:300});
    }

    // Actions
    function dash(){
      if(state.energy < 20) return;
      state.energy -= 20;
      state.player.iFrames = 300; // 300 ms invuln
      state.player.vx += (state.input.left?-1:state.input.right?1:0)*14;
      addTrail(state.player.x, state.player.y);
      beep(220,.08,'square',.2);
    }
    function phaseShift(){
      if(state.phaseCD>0) return;
      state.phase = 1200; // ms
      state.phaseCD = 3500; // cooldown
      beep(980,.12,'sine',.18);
      for(let i=0;i<6;i++) addSpark(state.player.x, state.player.y, 'rgba(140,220,255,.9)');
    }

    // Update
    let last=performance.now();
    function loop(now){
      const dt = now - last; last = now;
      if(state.running) update(dt); render();
      requestAnimationFrame(loop);
    } requestAnimationFrame(loop);

    function update(dt){
      const slowMo = state.phase>0 ? 0.35 : 1;
      const k = dt * 0.06 * slowMo * state.speed;

      state.t += dt;
      state.comboTime = Math.max(0, state.comboTime - dt);
      if(state.comboTime<=0) state.combo = Math.max(1, state.combo - 0.05);

      // spawn cadence
      if(state.t%320 < dt) spawn();

      // inputs
      const p = state.player;
      const accel = 0.8;
      if(state.input.left) p.vx -= accel;
      if(state.input.right) p.vx += accel;
      p.vx *= 0.9;
      p.x += p.vx;
      p.x = clamp(p.x, 40, W-40);

      if(state.input.dash){ dash(); state.input.dash=false; }
      if(state.input.phase){ phaseShift(); state.input.phase=false; }

      // phase and cooldown
      state.phase = Math.max(0, state.phase - dt);
      state.phaseCD = Math.max(0, state.phaseCD - dt);
      phaseEl.textContent = state.phase>0 ? 'Active' : (state.phaseCD>0 ? 'Cooldown' : 'Ready');

      // move entities
      for(const o of state.obstacles){ o.y += o.vy * k; }
      for(const pz of state.pulses){ pz.y += pz.vy * k; }
      for(const s of state.sparks){ s.x += s.vx; s.y += s.vy; s.life -= dt; }
      state.sparks = state.sparks.filter(s=>s.life>0);
      for(const tr of state.trails){ tr.life -= dt; }
      state.trails = state.trails.filter(tr=>tr.life>0);

      // collisions
      if(p.iFrames>0) p.iFrames -= dt;
      const inv = p.iFrames>0 || state.phase>0;
      // collect pulses
      for(let i=state.pulses.length-1;i>=0;i--){
        const z = state.pulses[i];
        if(rectOverlap({...p}, z)){
          if(z.type==='energy'){ state.energy = clamp(state.energy+12, 0, state.energyMax); beep(660,.06,'sine',.12); }
          else { addSpark(z.x,z.y,'rgba(198,128,255,.9)'); state.combo = clamp(state.combo+0.25, 1, 3.5); state.comboTime = 3000; state.score += Math.floor(10*state.combo); beep(440,.06,'triangle',.13); }
          state.pulses.splice(i,1);
        } else if(z.y > H+60) state.pulses.splice(i,1);
      }
      // obstacle hit
      if(!inv){
        for(let i=state.obstacles.length-1;i>=0;i--){
          const o = state.obstacles[i];
          if(rectOverlap({...p}, o)){
            // hit!
            addSpark(p.x, p.y,'rgba(255,90,120,.9)');
            state.score = Math.max(0, Math.floor(state.score*0.7));
            state.combo = 1; state.comboTime = 0;
            state.player.iFrames = 600; // brief invuln after hit
            beep(160,.08,'sawtooth',.18);
            break;
          }
        }
      }
      // clean obstacles
      for(let i=state.obstacles.length-1;i>=0;i--){
        if(state.obstacles[i].y > H+80) state.obstacles.splice(i,1);
      }

      // energy bar and scoring over time
      energyEl.style.width = `${(state.energy/state.energyMax)*100}%`;
      state.score += Math.floor(dt * 0.004 * (1 + state.combo*0.2));
      scoreEl.textContent = state.score;
      comboEl.textContent = `x${state.combo.toFixed(1)}`;
      timeEl.textContent = (state.t/1000).toFixed(1)+'s';
      spdEl.textContent = state.speed.toFixed(2)+'x';
    }

    // Render with glow/composite tricks
    function render(){
      // background gradient flow
      ctx.clearRect(0,0,W,H);
      const g = ctx.createLinearGradient(0,0,W,H);
      const t = state.t*0.0006;
      g.addColorStop(0, `hsl(${(200+40*Math.sin(t))|0}, 70%, 8%)`);
      g.addColorStop(1, `hsl(${(260+40*Math.cos(t))|0}, 70%, 10%)`);
      ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

      // lanes glow
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = 'rgba(160,200,255,.6)';
      ctx.lineWidth = 2;
      const lanes = 5;
      for(let i=1;i<lanes;i++){
        const x = (W/lanes)*i;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
      }
      ctx.restore();

      // trails
      for(const tr of state.trails){
        const a = tr.life/300;
        ctx.save();
        ctx.globalAlpha = a*0.35;
        const rg = ctx.createRadialGradient(tr.x, tr.y, 0, tr.x, tr.y, 240);
        rg.addColorStop(0,'rgba(120,220,255,.9)');
        rg.addColorStop(1,'rgba(120,220,255,0)');
        ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(tr.x,tr.y,240,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // pulses
      for(const pz of state.pulses){
        ctx.save();
        ctx.shadowBlur=16; ctx.shadowColor = pz.type==='energy'?'#2df':'#c6f';
        ctx.fillStyle = pz.type==='energy'?'#2df':'#c6f';
        roundRect(pz.x-pz.w/2, pz.y-pz.h/2, pz.w, pz.h, 6, true);
        ctx.restore();
      }

      // obstacles
      for(const o of state.obstacles){
        ctx.save();
        ctx.fillStyle = 'rgba(255, 90, 120, .85)';
        ctx.shadowBlur=12; ctx.shadowColor='#ff5e7a';
        roundRect(o.x-o.w/2, o.y-o.h/2, o.w, o.h, 8, true);
        ctx.restore();
      }

      // player
      const p = state.player;
      ctx.save();
      const glow = p.iFrames>0 || state.phase>0 ? '#9cf' : '#6cf';
      ctx.shadowBlur=18; ctx.shadowColor=glow;
      ctx.fillStyle = '#eaf1ff';
      roundRect(p.x-p.w/2, p.y-p.h/2, p.w, p.h, 6, true);
      // outline accent
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = glow; ctx.lineWidth=2;
      roundRect(p.x-p.w/2, p.y-p.h/2, p.w, p.h, 6, false);
      ctx.restore();

      // sparks
      for(const s of state.sparks){
        ctx.save();
        ctx.globalAlpha = s.life/360;
        ctx.fillStyle = s.color;
        ctx.beginPath(); ctx.arc(s.x, s.y, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // vignette
      ctx.save();
      const vg = ctx.createRadialGradient(W/2,H/2,0, W/2,H/2, Math.max(W,H));
      vg.addColorStop(0,'rgba(0,0,0,0)');
      vg.addColorStop(1,'rgba(0,0,0,.35)');
      ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    function roundRect(x,y,w,h,r,fill=true){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      if(fill) ctx.fill(); else ctx.stroke();
    }
  </script>
</body>
</html>
