<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Wave Shooter</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
  }

  body {
    background: radial-gradient(circle at top, #111 0, #02020a 55%, #000 100%);
    color: #fff;
    overflow: hidden;
  }

  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    background: radial-gradient(circle at center, #050816 0, #02020a 50%, #000 100%);
    display: flex;
    justify-content: center;
    align-items: center;
  }

  canvas {
    border: 2px solid #0ff;
    background: radial-gradient(circle at center, #050816 0, #02020a 60%, #000 100%);
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.4);
  }

  /* HUD */
  #hud {
    position: absolute;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    width: 86%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: none;
  }

  #leftHUD, #rightHUD {
    display: flex;
    gap: 12px;
    align-items: center;
  }

  .labelBox {
    padding: 6px 10px;
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.55);
    border: 1px solid rgba(0, 255, 255, 0.4);
    box-shadow: 0 0 7px rgba(0, 255, 255, 0.4);
    font-size: 13px;
  }

  /* HP BAR */
  #hpBarContainer {
    width: 180px;
    height: 18px;
    border-radius: 9px;
    background: linear-gradient(90deg, #300 0, #111 40%, #111 60%, #003 100%);
    overflow: hidden;
    border: 2px solid #f33;
    box-shadow: 0 0 12px rgba(255, 0, 0, 0.5);
    position: relative;
  }

  #hpBarFill {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #0f0, #ff0, #f80, #f00);
    transition: width 0.15s ease-out;
  }

  #hpText {
    position: absolute;
    width: 100%;
    text-align: center;
    top: 0;
    left: 0;
    font-size: 11px;
    text-shadow: 0 0 4px #000;
  }

  /* SHOP BUTTON (KERANJANG) */
  #shopButton {
    width: 36px;
    height: 36px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #0ff;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    pointer-events: auto;
  }

  #shopButton:hover {
    transform: scale(1.05);
    box-shadow: 0 0 16px rgba(0, 255, 255, 0.8);
  }

  #shopButtonIcon {
    width: 22px;
    height: 22px;
    border-radius: 4px;
    border: 2px solid #0ff;
    position: relative;
  }

  #shopButtonIcon::before {
    content: "";
    position: absolute;
    inset: 4px 2px;
    border-radius: 3px;
    border: 2px solid #0ff;
    border-top: none;
  }

  #shopButtonIcon::after {
    content: "";
    position: absolute;
    top: 1px;
    left: 5px;
    right: 5px;
    height: 3px;
    border-radius: 2px;
    border: 2px solid #0ff;
    border-bottom: none;
  }

  /* SHOP POPUP */
  #shopPopup {
    position: absolute;
    right: 20px;
    top: 60px;
    width: 270px;
    background: rgba(5, 8, 30, 0.96);
    border-radius: 10px;
    border: 2px solid #0ff;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
    padding: 10px;
    display: none;
    pointer-events: auto;
  }

  #shopHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  #shopHeader span {
    font-size: 13px;
  }

  #shopClose {
    cursor: pointer;
    font-size: 16px;
    padding: 2px 6px;
    border-radius: 4px;
    background: rgba(255, 0, 0, 0.15);
  }

  .shopSectionTitle {
    margin-top: 4px;
    margin-bottom: 4px;
    font-size: 12px;
    color: #0ff;
  }

  .shopItemList {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .shopItem {
    flex: 1 1 48%;
    padding: 6px;
    border-radius: 6px;
    background: rgba(10, 10, 30, 0.9);
    border: 1px solid rgba(0, 255, 255, 0.4);
    cursor: pointer;
    font-size: 11px;
  }

  .shopItem:hover {
    border-color: #0ff;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
  }

  .shopItem h4 {
    font-size: 11px;
    margin-bottom: 3px;
    color: #fff;
  }

  .shopItem p {
    font-size: 10px;
    line-height: 1.2;
    margin-bottom: 2px;
  }

  .shopCost {
    font-size: 10px;
    color: #ff0;
  }

  /* CENTER OVERLAYS */
  #centerOverlay {
    position: absolute;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
  }

  #messageBox {
    min-width: 260px;
    padding: 12px 16px;
    background: rgba(0, 0, 0, 0.82);
    border-radius: 10px;
    border: 2px solid #0ff;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
    text-align: center;
    display: none;
  }

  #messageBox h2 {
    margin-bottom: 6px;
  }

  #messageBox p {
    font-size: 13px;
    margin-bottom: 6px;
  }

  #messageHint {
    font-size: 11px;
    color: #0ff;
  }

  /* BOSS TRANSITION OVERLAY */
  #bossTransition {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at center, rgba(255,255,255,0.08) 0, rgba(0,0,0,0.92) 60%);
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    pointer-events: none;
  }

  #bossTransitionTitle {
    font-size: 32px;
    letter-spacing: 3px;
    margin-bottom: 6px;
    text-shadow: 0 0 12px #f0f, 0 0 24px #f0f;
  }

  #bossTransitionSubtitle {
    font-size: 14px;
    color: #0ff;
  }

</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="900" height="600"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div id="leftHUD">
      <div id="hpBarContainer">
        <div id="hpBarFill"></div>
        <div id="hpText">HP</div>
      </div>
      <div class="labelBox" id="coinLabel">Coin: 0</div>
      <div class="labelBox" id="waveLabel">Wave: 1</div>
      <div class="labelBox" id="modeLabel">Mode: Normal</div>
    </div>

    <div id="rightHUD">
      <div class="labelBox" id="fireRateLabel">Fire: Lv 1</div>
      <div class="labelBox" id="skinLabel">Skin: Default</div>
      <div id="shopButton">
        <div id="shopButtonIcon"></div>
      </div>
    </div>
  </div>

  <!-- SHOP -->
  <div id="shopPopup">
    <div id="shopHeader">
      <span>SHOP</span>
      <span id="shopClose">✕</span>
    </div>
    <div class="shopSectionTitle">Fire Rate Upgrade</div>
    <div class="shopItemList" id="fireRateShopList"></div>

    <div class="shopSectionTitle">Skins</div>
    <div class="shopItemList" id="skinShopList"></div>
  </div>

  <!-- CENTER MESSAGE -->
  <div id="centerOverlay">
    <div id="messageBox">
      <h2 id="messageTitle"></h2>
      <p id="messageBody"></p>
      <div id="messageHint">Press [SPACE] to continue</div>
    </div>
  </div>

  <!-- BOSS TRANSITION -->
  <div id="bossTransition">
    <div id="bossTransitionTitle">BOSS INCOMING</div>
    <div id="bossTransitionSubtitle">Prepare yourself...</div>
  </div>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const hpBarFill = document.getElementById("hpBarFill");
  const hpText = document.getElementById("hpText");
  const coinLabel = document.getElementById("coinLabel");
  const waveLabel = document.getElementById("waveLabel");
  const modeLabel = document.getElementById("modeLabel");
  const fireRateLabel = document.getElementById("fireRateLabel");
  const skinLabel = document.getElementById("skinLabel");

  const shopButton = document.getElementById("shopButton");
  const shopPopup = document.getElementById("shopPopup");
  const shopClose = document.getElementById("shopClose");
  const fireRateShopList = document.getElementById("fireRateShopList");
  const skinShopList = document.getElementById("skinShopList");

  const centerOverlay = document.getElementById("centerOverlay");
  const messageBox = document.getElementById("messageBox");
  const messageTitle = document.getElementById("messageTitle");
  const messageBody = document.getElementById("messageBody");

  const bossTransition = document.getElementById("bossTransition");

  const gameWidth = canvas.width;
  const gameHeight = canvas.height;

  // ================== GAME STATE ==================
  let gameState = "start";  // "start" | "playing" | "waveClear" | "bossTransition" | "gameOver"

  const playerBaseStats = {
    maxHp: 100,
    moveSpeed: 3.2,
    bulletSpeed: 6.2,
    baseFireDelay: 650, // awal pelan
  };

  const player = {
    x: gameWidth / 2,
    y: gameHeight - 90,
    radius: 16,
    hp: playerBaseStats.maxHp,
    maxHp: playerBaseStats.maxHp,
    moveSpeed: playerBaseStats.moveSpeed,
    bulletSpeed: playerBaseStats.bulletSpeed,
    fireDelay: playerBaseStats.baseFireDelay,
    lastShotTime: 0,
    autoShoot: true,
    skinId: "default",
    damage: 1,
    secretUnitUnlocked: false,
  };

  let coins = 0;
  let wave = 1;

  const keys = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false,
    w: false,
    a: false,
    s: false,
    d: false,
  };

  let mouseX = gameWidth / 2;
  let mouseY = gameHeight / 2;

  const bullets = [];
  const enemies = [];
  const enemyBullets = [];
  const drops = [];
  const floatingTexts = [];

  // wave & spawn
  let lastEnemySpawnTime = 0;
  let enemySpawnCooldown = 1200; // akan turun tiap naik wave
  let enemiesToSpawn = 10;       // musuh per wave
  let spawnedCount = 0;
  let waveBossEvery = 5;         // tiap 5 wave → boss
  let inBossFight = false;
  let boss = null;

  // shop data
  let fireRateLevel = 1;
  const maxFireRateLevel = 5;
  const fireRateLevels = [
    null,
    { level: 1, delay: 650, cost: 0, desc: "Default auto shoot" },
    { level: 2, delay: 520, cost: 60, desc: "Sedikit lebih cepat" },
    { level: 3, delay: 400, cost: 120, desc: "Lumayan cepat" },
    { level: 4, delay: 280, cost: 200, desc: "Cepat" },
    { level: 5, delay: 170, cost: 320, desc: "Sangat cepat" },
  ];

  const skins = [
    {
      id: "default",
      name: "Default",
      cost: 0,
      colorBody: "#0ff",
      colorCore: "#fff",
      outline: "#0ff",
      desc: "Skin awal.",
    },
    {
      id: "ember",
      name: "Ember",
      cost: 150,
      colorBody: "#f90",
      colorCore: "#ff0",
      outline: "#f30",
      desc: "+5% move speed.",
      bonus: { moveSpeed: 0.05 },
    },
    {
      id: "shadow",
      name: "Shadow",
      cost: 150,
      colorBody: "#888",
      colorCore: "#fff",
      outline: "#aaa",
      desc: "+10 max HP.",
      bonus: { maxHp: 10 },
    },
    {
      id: "volt",
      name: "Volt",
      cost: 200,
      colorBody: "#0f0",
      colorCore: "#fff",
      outline: "#0f0",
      desc: "+5% fire rate.",
      bonus: { fireRate: 0.05 },
    },
  ];
  let ownedSkins = new Set(["default"]);

  // secret unit config
  const secretUnitConfig = {
    dropChance: 0.07,  // 7% dari musuh tertentu
    hpBonus: 25,
    damageBonus: 1,
    speedBonus: 0.3,
    fireRateMultiplier: 0.8,
  };

  // =============== HELPER & UTILS ===============
  function randRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function addFloatingText(text, x, y, color = "#0ff") {
    floatingTexts.push({
      text,
      x,
      y,
      color,
      life: 900,
      created: performance.now(),
    });
  }

  // =============== PLAYER & SKIN LOGIC ===============
  function applySkinStats() {
    // reset base
    player.maxHp = playerBaseStats.maxHp;
    player.moveSpeed = playerBaseStats.moveSpeed;
    player.bulletSpeed = playerBaseStats.bulletSpeed;
    player.fireDelay = fireRateLevels[fireRateLevel].delay;

    // apply skin
    const skin = skins.find(s => s.id === player.skinId);
    if (skin && skin.bonus) {
      if (skin.bonus.maxHp) player.maxHp += skin.bonus.maxHp;
      if (skin.bonus.moveSpeed) player.moveSpeed *= (1 + skin.bonus.moveSpeed);
      if (skin.bonus.fireRate) player.fireDelay *= (1 - skin.bonus.fireRate);
    }

    // apply secret unit
    if (player.secretUnitUnlocked) {
      player.maxHp += secretUnitConfig.hpBonus;
      player.damage = 1 + secretUnitConfig.damageBonus; // damage naik jelas
      player.moveSpeed += secretUnitConfig.speedBonus;
      player.fireDelay *= secretUnitConfig.fireRateMultiplier;
    }

    if (player.hp > player.maxHp) player.hp = player.maxHp;
  }

  function getCurrentSkinColors() {
    const skin = skins.find(s => s.id === player.skinId) ||
      skins.find(s => s.id === "default");
    return {
      body: skin.colorBody,
      core: skin.colorCore,
      outline: skin.outline,
    };
  }

  // =============== SHOP UI ===============
  function buildFireRateShop() {
    fireRateShopList.innerHTML = "";
    for (let i = 2; i <= maxFireRateLevel; i++) {
      const data = fireRateLevels[i];
      const item = document.createElement("div");
      item.className = "shopItem";

      let owned = fireRateLevel >= i;
      item.innerHTML = `
        <h4>Lv ${i}</h4>
        <p>${data.desc}</p>
        <p class="shopCost">${owned ? "Owned" : data.cost + " coin"}</p>
      `;

      if (!owned) {
        item.onclick = () => {
          if (coins >= data.cost && fireRateLevel === i - 1) {
            coins -= data.cost;
            fireRateLevel = i;
            player.fireDelay = data.delay;
            applySkinStats();
            updateHUD();
            addFloatingText("-" + data.cost + " coin", canvas.width - 100, 50, "#ff0");
            buildFireRateShop();
          } else {
            addFloatingText("Tidak cukup coin / urutan salah", canvas.width - 200, 80, "#f66");
          }
        };
      } else {
        item.style.opacity = 0.6;
        item.style.cursor = "default";
      }

      fireRateShopList.appendChild(item);
    }
  }

  function buildSkinShop() {
    skinShopList.innerHTML = "";
    skins.forEach(skin => {
      const item = document.createElement("div");
      item.className = "shopItem";

      const isOwned = ownedSkins.has(skin.id);
      const isEquipped = player.skinId === skin.id;

      item.innerHTML = `
        <h4>${skin.name}</h4>
        <p>${skin.desc || ""}</p>
        <p class="shopCost">${
          skin.cost === 0
            ? (isEquipped ? "Equipped" : "Default")
            : isOwned
              ? (isEquipped ? "Equipped" : "Owned")
              : skin.cost + " coin"
        }</p>
      `;

      item.style.borderColor = skin.colorBody;

      if (!isOwned && skin.cost > 0) {
        item.onclick = () => {
          if (coins >= skin.cost) {
            coins -= skin.cost;
            ownedSkins.add(skin.id);
            player.skinId = skin.id;
            applySkinStats();
            updateHUD();
            addFloatingText("Skin unlocked: " + skin.name, canvas.width / 2, 100, skin.colorBody);
            buildSkinShop();
          } else {
            addFloatingText("Coin tidak cukup", canvas.width / 2, 100, "#f66");
          }
        };
      } else {
        item.onclick = () => {
          if (!isEquipped) {
            player.skinId = skin.id;
            applySkinStats();
            updateHUD();
            buildSkinShop();
          }
        };
      }

      skinShopList.appendChild(item);
    });
  }

  // =============== UI UPDATE ===============
  function updateHUD() {
    hpBarFill.style.width = (player.hp / player.maxHp * 100) + "%";
    hpText.textContent = `HP ${Math.round(player.hp)}/${player.maxHp}`;
    coinLabel.textContent = "Coin: " + coins;
    waveLabel.textContent = "Wave: " + wave;
    fireRateLabel.textContent = "Fire: Lv " + fireRateLevel;
    const currentSkin = skins.find(s => s.id === player.skinId) || skins[0];
    skinLabel.textContent = "Skin: " + currentSkin.name;
    modeLabel.textContent = inBossFight ? "Mode: Boss" : "Mode: Normal";
  }

  function showMessage(title, body) {
    messageTitle.textContent = title;
    messageBody.textContent = body;
    messageBox.style.display = "block";
    centerOverlay.style.pointerEvents = "auto";
  }

  function hideMessage() {
    messageBox.style.display = "none";
    centerOverlay.style.pointerEvents = "none";
  }

  function showBossTransition() {
    bossTransition.style.display = "flex";
    bossTransition.style.opacity = "1";
    gameState = "bossTransition";
    let start = performance.now();

    function fadeLoop(now) {
      const t = (now - start) / 1500;
      if (t >= 1) {
        bossTransition.style.opacity = "0";
        bossTransition.style.display = "none";
        startBoss();
        gameState = "playing";
        return;
      }
      bossTransition.style.opacity = (1 - t).toString();
      requestAnimationFrame(fadeLoop);
    }

    requestAnimationFrame(fadeLoop);
  }

  // =============== INPUT HANDLING ===============
  window.addEventListener("keydown", (e) => {
    if (e.key in keys) {
      keys[e.key] = true;
    }
    if (e.key === " ") {
      if (gameState === "start") {
        startGame();
      } else if (gameState === "waveClear") {
        nextWave();
      } else if (gameState === "gameOver") {
        restartGame();
      }
      e.preventDefault();
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.key in keys) {
      keys[e.key] = false;
    }
  });

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
  });

  shopButton.addEventListener("click", () => {
    if (shopPopup.style.display === "none" || shopPopup.style.display === "") {
      shopPopup.style.display = "block";
    } else {
      shopPopup.style.display = "none";
    }
  });

  shopClose.addEventListener("click", () => {
    shopPopup.style.display = "none";
  });

  // =============== GAME FLOW ===============
  function startGame() {
    gameState = "playing";
    hideMessage();
    resetWave(1);
  }

  function resetWave(waveNumber) {
    wave = waveNumber;
    enemies.length = 0;
    enemyBullets.length = 0;
    drops.length = 0;
    boss = null;
    inBossFight = false;

    // scaling spawn rate dan jumlah musuh
    enemySpawnCooldown = Math.max(350, 1300 - wave * 70);
    enemiesToSpawn = 10 + Math.floor(wave * 2.2);
    spawnedCount = 0;

    updateHUD();
  }

  function startBoss() {
    inBossFight = true;
    boss = {
      x: gameWidth / 2,
      y: 110,
      radius: 40,
      hp: 70 + wave * 15,
      maxHp: 70 + wave * 15,
      phase: 1,
      lastShotTime: 0,
      shotCooldown: 900,
      moveDir: 1,
    };
    enemies.length = 0;
    enemyBullets.length = 0;
  }

  function nextWave() {
    gameState = "playing";
    hideMessage();
    resetWave(wave + 1);
  }

  function triggerWaveClear() {
    gameState = "waveClear";
    showMessage(
      "Wave Clear",
      `Wave ${wave} selesai. Coin: ${coins}.`
    );
  }

  function triggerGameOver() {
    gameState = "gameOver";
    showMessage(
      "Game Over",
      `Kamu tumbang di wave ${wave}. Total coin: ${coins}.`
    );
  }

  function restartGame() {
    coins = 0;
    wave = 1;
    player.hp = playerBaseStats.maxHp;
    player.damage = 1;
    player.secretUnitUnlocked = false;
    fireRateLevel = 1;
    player.skinId = "default";
    applySkinStats();

    enemies.length = 0;
    enemyBullets.length = 0;
    drops.length = 0;
    boss = null;
    inBossFight = false;

    gameState = "playing";
    hideMessage();
    resetWave(1);
  }

  // =============== ENEMY & BOSS SPAWN ===============
  function spawnEnemy() {
    const typeRoll = Math.random();
    let type = "basic";
    if (typeRoll > 0.7) type = "fast";
    if (typeRoll > 0.9) type = "tank";

    const enemy = {
      x: randRange(40, gameWidth - 40),
      y: -20,
      radius: 14,
      hp: 3,
      maxHp: 3,
      speed: 1 + wave * 0.08,
      type,
      lastShotTime: 0,
      shotCooldown: 1300 + randRange(-250, 300),
      canShoot: Math.random() < 0.5,
    };

    if (type === "fast") {
      enemy.speed *= 1.6;
      enemy.hp = enemy.maxHp = 2 + wave * 0.4;
      enemy.radius = 12;
    } else if (type === "tank") {
      enemy.speed *= 0.75;
      enemy.hp = enemy.maxHp = 6 + wave * 0.9;
      enemy.radius = 18;
    } else {
      enemy.hp = enemy.maxHp = 3 + wave * 0.5;
    }

    enemies.push(enemy);
  }

  function spawnDrop(x, y, type) {
    drops.push({
      x,
      y,
      radius: 10,
      type,
      vy: 1.2,
    });
  }

  function rollDrops(enemy) {
    // normal drop item
    if (Math.random() < 0.3) {
      const roll = Math.random();
      if (roll < 0.35) spawnDrop(enemy.x, enemy.y, "hp");
      else if (roll < 0.7) spawnDrop(enemy.x, enemy.y, "dmg");
      else spawnDrop(enemy.x, enemy.y, "speed");
    }

    // secret unit drop (musuh fast/tank, wave >= 3)
    if (!player.secretUnitUnlocked && wave >= 3) {
      if ((enemy.type === "tank" || enemy.type === "fast") &&
          Math.random() < secretUnitConfig.dropChance) {
        spawnDrop(enemy.x, enemy.y, "secret");
      }
    }

    // coin reward
    const coinGain = 3 + Math.floor(Math.random() * 3) + Math.floor(wave * 0.6);
    coins += coinGain;
    addFloatingText("+" + coinGain + " coin", enemy.x, enemy.y, "#ff0");
  }

  function applyDropEffect(drop) {
    if (drop.type === "hp") {
      const heal = 14;
      player.hp = Math.min(player.hp + heal, player.maxHp);
      addFloatingText("+HP", drop.x, drop.y, "#0f0");
    } else if (drop.type === "dmg") {
      player.damage += 0.4;
      addFloatingText("+DMG", drop.x, drop.y, "#f80");
    } else if (drop.type === "speed") {
      player.moveSpeed += 0.15;
      addFloatingText("+SPD", drop.x, drop.y, "#0ff");
    } else if (drop.type === "secret") {
      player.secretUnitUnlocked = true;
      applySkinStats();
      addFloatingText("SECRET UNIT!", drop.x, drop.y, "#ff0");
    }
    updateHUD();
  }

  // =============== UPDATE LOOP ===============
  function update(delta, now) {
    if (gameState !== "playing") return;

    // player movement
    let moveX = 0;
    let moveY = 0;
    if (keys.ArrowLeft || keys.a) moveX -= 1;
    if (keys.ArrowRight || keys.d) moveX += 1;
    if (keys.ArrowUp || keys.w) moveY -= 1;
    if (keys.ArrowDown || keys.s) moveY += 1;

    if (moveX !== 0 || moveY !== 0) {
      const len = Math.sqrt(moveX * moveX + moveY * moveY);
      moveX /= len;
      moveY /= len;
    }

    player.x += moveX * player.moveSpeed * (delta / 16.67);
    player.y += moveY * player.moveSpeed * (delta / 16.67);

    // clamp
    player.x = Math.max(30, Math.min(gameWidth - 30, player.x));
    player.y = Math.max(50, Math.min(gameHeight - 40, player.y));

    // auto shooting
    if (player.autoShoot) {
      if (now - player.lastShotTime >= player.fireDelay) {
        shootBullet(now);
      }
    }

    // update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx;
      b.y += b.vy;
      if (b.y < -20 || b.x < -20 || b.x > gameWidth + 20 || b.y > gameHeight + 20) {
        bullets.splice(i, 1);
      }
    }

    // spawn enemy kalau bukan boss fight & masih ada kuota spawn
    if (!inBossFight && spawnedCount < enemiesToSpawn) {
      if (now - lastEnemySpawnTime >= enemySpawnCooldown) {
        spawnEnemy();
        spawnedCount++;
        lastEnemySpawnTime = now;
      }
    }

    // update enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.y += e.speed * (delta / 16.67);

      // enemy shooting
      if (e.canShoot) {
        if (now - e.lastShotTime >= e.shotCooldown) {
          enemyShoot(e);
          e.lastShotTime = now;
        }
      }

      // keluar layar
      if (e.y > gameHeight + 40) {
        enemies.splice(i, 1);
      }
    }

    // update boss
    if (boss) {
      updateBoss(delta, now);
    }

    // update enemy bullets
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      b.x += b.vx;
      b.y += b.vy;
      if (b.y < -20 || b.x < -20 || b.x > gameWidth + 20 || b.y > gameHeight + 20) {
        enemyBullets.splice(i, 1);
      }
    }

    // update drops
    for (let i = drops.length - 1; i >= 0; i--) {
      const d = drops[i];
      d.y += d.vy * (delta / 16.67);
      if (d.y > gameHeight + 20) {
        drops.splice(i, 1);
      }
    }

    // update floating text
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const f = floatingTexts[i];
      const lifePercent = (now - f.created) / f.life;
      f.y -= 0.03 * delta;
      if (lifePercent >= 1) {
        floatingTexts.splice(i, 1);
      }
    }

    // collisions
    handleCollisions();

    // cek wave clear / boss spawn
    if (!inBossFight) {
      const allSpawned = spawnedCount >= enemiesToSpawn;
      if (allSpawned && enemies.length === 0) {
        // cek apakah wave ini harus boss
        if (wave % waveBossEvery === 0) {
          showBossTransition();
        } else {
          triggerWaveClear();
        }
      }
    } else {
      // boss mode: wave clear kalau boss mati dan tidak ada musuh/bullet sisa
      if (!boss && enemies.length === 0) {
        triggerWaveClear();
      }
    }

    updateHUD();
  }

  function shootBullet(now) {
    const dx = mouseX - player.x;
    const dy = mouseY - player.y;
    const len = Math.sqrt(dx * dx + dy * dy) || 1;
    const vx = (dx / len) * player.bulletSpeed;
    const vy = (dy / len) * player.bulletSpeed;

    bullets.push({
      x: player.x,
      y: player.y,
      radius: 4,
      vx,
      vy,
      damage: player.damage,
    });

    player.lastShotTime = now;
  }

  function enemyShoot(enemy) {
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const len = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = 3.4 + wave * 0.07;
    const vx = (dx / len) * speed;
    const vy = (dy / len) * speed;

    enemyBullets.push({
      x: enemy.x,
      y: enemy.y,
      radius: 4,
      vx,
      vy,
      damage: 5 + wave * 0.4,
      color: "#f55",
    });
  }

  function updateBoss(delta, now) {
    if (!boss) return;

    // gerak horizontal
    boss.x += boss.moveDir * 1.7 * (delta / 16.67);
    if (boss.x < 80) {
      boss.x = 80;
      boss.moveDir = 1;
    } else if (boss.x > gameWidth - 80) {
      boss.x = gameWidth - 80;
      boss.moveDir = -1;
    }

    // phase logic
    const hpPercent = boss.hp / boss.maxHp;
    if (hpPercent < 0.66 && boss.phase === 1) {
      boss.phase = 2;
      boss.shotCooldown = 650;
      addFloatingText("Boss Phase 2", boss.x, boss.y - 50, "#ff0");
    } else if (hpPercent < 0.33 && boss.phase === 2) {
      boss.phase = 3;
      boss.shotCooldown = 420;
      addFloatingText("Boss Phase 3", boss.x, boss.y - 50, "#ff0");
    }

    // shooting pattern
    if (now - boss.lastShotTime >= boss.shotCooldown) {
      if (boss.phase === 1) {
        bossShootSingle();
      } else if (boss.phase === 2) {
        bossShootSpread();
      } else if (boss.phase === 3) {
        bossShootRadial();
      }
      boss.lastShotTime = now;
    }
  }

  function bossShootSingle() {
    enemyBullets.push({
      x: boss.x,
      y: boss.y + boss.radius - 5,
      radius: 5,
      vx: 0,
      vy: 4,
      damage: 11 + wave * 0.7,
      color: "#ff0",
    });
  }

  function bossShootSpread() {
    const angles = [-0.2, -0.05, 0.05, 0.2];
    angles.forEach(a => {
      const speed = 4;
      enemyBullets.push({
        x: boss.x,
        y: boss.y + boss.radius - 5,
        radius: 4,
        vx: Math.sin(a) * speed,
        vy: Math.cos(a) * speed,
        damage: 9 + wave * 0.5,
        color: "#ffa500",
      });
    });
  }

  function bossShootRadial() {
    const count = 12;
    const speed = 3.2;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      enemyBullets.push({
        x: boss.x,
        y: boss.y,
        radius: 4,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        damage: 8 + wave * 0.4,
        color: "#f0f",
      });
    }
  }

  // =============== COLLISIONS ===============
  function handleCollisions() {
    // bullet player → musuh / boss
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      let hit = false;

      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (distance(b.x, b.y, e.x, e.y) < b.radius + e.radius) {
          e.hp -= b.damage;
          hit = true;
          if (e.hp <= 0) {
            rollDrops(e);
            enemies.splice(j, 1);
          }
          break;
        }
      }

      if (!hit && boss) {
        if (distance(b.x, b.y, boss.x, boss.y) < b.radius + boss.radius) {
          boss.hp -= b.damage;
          hit = true;
          if (boss.hp <= 0) {
            rollDrops(boss);
            boss = null;
            inBossFight = false;
          }
        }
      }

      if (hit) {
        bullets.splice(i, 1);
      }
    }

    // enemy → player
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (distance(player.x, player.y, e.x, e.y) < player.radius + e.radius) {
        player.hp -= 10;
        enemies.splice(i, 1);
        addFloatingText("-HP", player.x, player.y, "#f44");
        if (player.hp <= 0) {
          triggerGameOver();
          return;
        }
      }
    }

    // enemy bullets → player
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      if (distance(player.x, player.y, b.x, b.y) < player.radius + b.radius) {
        player.hp -= b.damage;
        enemyBullets.splice(i, 1);
        addFloatingText("-" + Math.floor(b.damage), player.x, player.y, "#f44");
        if (player.hp <= 0) {
          triggerGameOver();
          return;
        }
      }
    }

    // boss body → player
    if (boss) {
      if (distance(player.x, player.y, boss.x, boss.y) < player.radius + boss.radius) {
        player.hp -= 18;
        addFloatingText("-HP", player.x, player.y, "#f44");
        if (player.hp <= 0) {
          triggerGameOver();
          return;
        }
      }
    }

    // player → drops
    for (let i = drops.length - 1; i >= 0; i--) {
      const d = drops[i];
      if (distance(player.x, player.y, d.x, d.y) < player.radius + d.radius) {
        applyDropEffect(d);
        drops.splice(i, 1);
      }
    }
  }

  // =============== DRAW ===============
  function drawBackgroundGrid() {
    ctx.save();
    ctx.strokeStyle = "rgba(0,255,255,0.12)";
    ctx.lineWidth = 0.5;
    const spacing = 40;
    for (let x = 0; x < gameWidth; x += spacing) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, gameHeight);
      ctx.stroke();
    }
    for (let y = 0; y < gameHeight; y += spacing) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(gameWidth, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawPlayer() {
    const colors = getCurrentSkinColors();
    ctx.save();
    ctx.translate(player.x, player.y);

    ctx.beginPath();
    ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, player.radius - 2, 0, Math.PI * 2);
    ctx.strokeStyle = colors.outline;
    ctx.lineWidth = 3;
    ctx.stroke();

    const dx = mouseX - player.x;
    const dy = mouseY - player.y;
    const angle = Math.atan2(dy, dx);

    ctx.beginPath();
    ctx.arc(0, 0, player.radius - 5, 0, Math.PI * 2);
    ctx.fillStyle = colors.body;
    ctx.fill();

    ctx.beginPath();
    ctx.arc(Math.cos(angle) * 7, Math.sin(angle) * 7, 5, 0, Math.PI * 2);
    ctx.fillStyle = colors.core;
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(Math.cos(angle) * (player.radius - 1), Math.sin(angle) * (player.radius - 1));
    ctx.lineTo(Math.cos(angle) * (player.radius + 6), Math.sin(angle) * (player.radius + 6));
    ctx.strokeStyle = colors.core;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  function drawBullets() {
    ctx.save();
    bullets.forEach(b => {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fillStyle = "#0ff";
      ctx.shadowColor = "#0ff";
      ctx.shadowBlur = 8;
      ctx.fill();
    });
    ctx.restore();
  }

  function drawEnemies() {
    ctx.save();
    enemies.forEach(e => {
      ctx.save();
      ctx.translate(e.x, e.y);

      ctx.beginPath();
      ctx.arc(0, 0, e.radius + 3, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
      if (e.type === "fast") ctx.fillStyle = "#f90";
      else if (e.type === "tank") ctx.fillStyle = "#f33";
      else ctx.fillStyle = "#f0f";
      ctx.fill();

      const hpPercent = e.hp / e.maxHp;
      const barWidth = e.radius * 2;
      const barHeight = 3;
      ctx.fillStyle = "#400";
      ctx.fillRect(-e.radius, -e.radius - 8, barWidth, barHeight);
      ctx.fillStyle = "#0f0";
      ctx.fillRect(-e.radius, -e.radius - 8, barWidth * hpPercent, barHeight);

      ctx.restore();
    });
    ctx.restore();
  }

  function drawBoss() {
    if (!boss) return;
    ctx.save();
    ctx.translate(boss.x, boss.y);

    ctx.beginPath();
    ctx.arc(0, 0, boss.radius + 8, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, boss.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#ff0066";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(0, 0, boss.radius - 16, 0, Math.PI * 2);
    ctx.fillStyle = "#fff";
    ctx.fill();

    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const angle = Math.atan2(dy, dx);
    ctx.beginPath();
    ctx.arc(Math.cos(angle) * 14, Math.sin(angle) * 14, 6, 0, Math.PI * 2);
    ctx.fillStyle = "#ff0";
    ctx.fill();

    const hpPercent = boss.hp / boss.maxHp;
    const barWidth = 140;
    const barHeight = 8;
    ctx.fillStyle = "#400";
    ctx.fillRect(-barWidth / 2, -boss.radius - 18, barWidth, barHeight);
    ctx.fillStyle = "#f00";
    ctx.fillRect(-barWidth / 2, -boss.radius - 18, barWidth * hpPercent, barHeight);

    ctx.restore();
  }

  function drawEnemyBullets() {
    ctx.save();
    enemyBullets.forEach(b => {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fillStyle = b.color || "#f55";
      ctx.shadowColor = b.color || "#f55";
      ctx.shadowBlur = 8;
      ctx.fill();
    });
    ctx.restore();
  }

  function drawDrops() {
    ctx.save();
    drops.forEach(d => {
      ctx.save();
      ctx.translate(d.x, d.y);
      let color = "#0ff";
      let label = "?";
      if (d.type === "hp") {
        color = "#0f0";
        label = "HP";
      } else if (d.type === "dmg") {
        color = "#f80";
        label = "DMG";
      } else if (d.type === "speed") {
        color = "#0ff";
        label = "SPD";
      } else if (d.type === "secret") {
        color = "#ff0";
        label = "S";
      }

      ctx.beginPath();
      ctx.arc(0, 0, d.radius, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(0, 0, d.radius - 2, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();

      ctx.fillStyle = "#000";
      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, 0, 0);

      ctx.restore();
    });
    ctx.restore();
  }

  function drawFloatingTexts(now) {
    floatingTexts.forEach(f => {
      const lifePercent = (now - f.created) / f.life;
      const alpha = Math.max(0, 1 - lifePercent);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = f.color;
      ctx.font = "11px Arial";
      ctx.textAlign = "center";
      ctx.fillText(f.text, f.x, f.y);
      ctx.restore();
    });
  }

  function drawCursorReticle() {
    ctx.save();
    const r = 10;
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, r, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(0,255,255,0.6)";
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  }

  // =============== MAIN LOOP ===============
  let lastTime = performance.now();

  function gameLoop(now) {
    const delta = now - lastTime;
    lastTime = now;

    update(delta, now);

    ctx.clearRect(0, 0, gameWidth, gameHeight);
    drawBackgroundGrid();
    drawPlayer();
    drawBullets();
    drawEnemies();
    drawBoss();
    drawEnemyBullets();
    drawDrops();
    drawFloatingTexts(now);
    drawCursorReticle();

    requestAnimationFrame(gameLoop);
  }

  // init
  applySkinStats();
  updateHUD();
  buildFireRateShop();
  buildSkinShop();

  showMessage(
    "Neon Wave Shooter",
    "Gerak: WASD / panah. Auto shoot pelan, arah tembakan mengikuti kursor. Naik wave → spawn musuh makin cepat, setiap beberapa wave akan ada boss."
  );

  requestAnimationFrame(gameLoop);
</script>
</body>
</html>
